<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KarmaEngine: Karma::KarmaGuiVulkanHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KarmaEngine
   </div>
   <div id="projectbrief">Game Engine for practical learning and research purposes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Karma</b></li><li class="navelem"><a class="el" href="class_karma_1_1_karma_gui_vulkan_handler.html">KarmaGuiVulkanHandler</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_karma_1_1_karma_gui_vulkan_handler-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Karma::KarmaGuiVulkanHandler Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class for required Vulkan routines for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> Vulkan backend.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_karma_gui_vulkan_handler_8h_source.html">KarmaGuiVulkanHandler.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a19d9046ecead4192278f5f15dddcca51" id="r_a19d9046ecead4192278f5f15dddcca51"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19d9046ecead4192278f5f15dddcca51">KarmaGui_ImplVulkan_MemoryType</a> (VkMemoryPropertyFlags properties, uint32_t type_bits)</td></tr>
<tr class="memdesc:a19d9046ecead4192278f5f15dddcca51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reports memory relevant type information for the specified physical device (the GPU, represented by <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ad2473723d37a6a5ed216184210e01a27" title="The handle to the Vulkan&#39;s software representaion of GPU, for use in backend.">KarmaGui_ImplVulkan_InitInfo.PhysicalDevice</a>), based on supplied properties and type_bits (not exceeding a valid limit).  <br /></td></tr>
<tr class="separator:a19d9046ecead4192278f5f15dddcca51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fe3b6d98631be363c0d4a3990c4b8f" id="r_a56fe3b6d98631be363c0d4a3990c4b8f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56fe3b6d98631be363c0d4a3990c4b8f">CreateOrResizeBuffer</a> (VkBuffer &amp;buffer, VkDeviceMemory &amp;bufferMemory, VkDeviceSize &amp;pBufferSize, size_t newSize, VkBufferUsageFlagBits usage)</td></tr>
<tr class="memdesc:a56fe3b6d98631be363c0d4a3990c4b8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates new vulkan buffer and allocates appropriate memory based upon the supplied newSize (appropriately aligned) and usage.  <br /></td></tr>
<tr class="separator:a56fe3b6d98631be363c0d4a3990c4b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac989f0dd29c02b3489ff33a31c0b261b" id="r_ac989f0dd29c02b3489ff33a31c0b261b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac989f0dd29c02b3489ff33a31c0b261b">KarmaGui_ImplVulkan_SetupRenderState</a> (<a class="el" href="struct_k_g_draw_data.html">KGDrawData</a> *drawData, VkPipeline pipeline, VkCommandBuffer commandBuffer, <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers</a> *remderingBufferData, int width, int height)</td></tr>
<tr class="memdesc:ac989f0dd29c02b3489ff33a31c0b261b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to bind index/vertex buffers, setup a external viewport, and bind pipeline. Usually for rendering of <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> windows and all that.  <br /></td></tr>
<tr class="separator:ac989f0dd29c02b3489ff33a31c0b261b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09e6fbd79125a5759c82f87aaa7eed33" id="r_a09e6fbd79125a5759c82f87aaa7eed33"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09e6fbd79125a5759c82f87aaa7eed33">KarmaGui_ImplVulkan_SetupRenderStateFor3DRendering</a> (<a class="el" href="class_karma_1_1_scene.html">Scene</a> *sceneToDraw, VkCommandBuffer commandBuffer, <a class="el" href="struct_k_g_draw_data.html">KGDrawData</a> *drawData)</td></tr>
<tr class="memdesc:a09e6fbd79125a5759c82f87aaa7eed33"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to bind index/vertex buffers, setup a external viewport, and bind pipeline. Specifically for 3D rendering in KarmaGUI's window for (experimental) 3D exhibition.  <br /></td></tr>
<tr class="separator:a09e6fbd79125a5759c82f87aaa7eed33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd34e93e2175ac37b4c01191aa77298b" id="r_abd34e93e2175ac37b4c01191aa77298b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd34e93e2175ac37b4c01191aa77298b">KarmaGui_ImplVulkan_CreateShaderModules</a> (VkDevice device, const VkAllocationCallbacks *allocator)</td></tr>
<tr class="memdesc:abd34e93e2175ac37b4c01191aa77298b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A routine to create the shader modules (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#aaa4f696be8c1c601fdb26abcbadc56a6" title="Opaque handle to a vertex shader module object for backend. Shader modules contain shader code and on...">KarmaGui_ImplVulkan_Data.ShaderModuleVert</a> and <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ac35e29609b5537b35dde85d6957a4456" title="Opaque handle to fragment shader module object for backend. Shader modules contain shader code and on...">KarmaGui_ImplVulkan_Data.ShaderModuleFrag</a>) for the backend GraphicsPipeline (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data.Pipeline</a>).  <br /></td></tr>
<tr class="separator:abd34e93e2175ac37b4c01191aa77298b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa583f5e1a61b93581443dc2382056da6" id="r_aa583f5e1a61b93581443dc2382056da6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa583f5e1a61b93581443dc2382056da6">KarmaGui_ImplVulkan_CreateFontSampler</a> (VkDevice device, const VkAllocationCallbacks *allocator)</td></tr>
<tr class="memdesc:aa583f5e1a61b93581443dc2382056da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bilinear sampling object is created for font and stored in <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a1176bcb25813c28c571cee1d682fe36a" title="Opaque handle to a sampler object. The object represents the state of an image sampler which is used ...">KarmaGui_ImplVulkan_Data.FontSampler</a> if not done already in <a class="el" href="#a8798f337eabad2a1268cfbaa6114643c" title="Generates or creates the following objects.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDeviceObjects()</a>.  <br /></td></tr>
<tr class="separator:aa583f5e1a61b93581443dc2382056da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ede603ade2ed4ff6d9c093edb53868" id="r_a10ede603ade2ed4ff6d9c093edb53868"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10ede603ade2ed4ff6d9c093edb53868">KarmaGui_ImplVulkan_CreateDescriptorSetLayout</a> (VkDevice device, const VkAllocationCallbacks *allocator)</td></tr>
<tr class="memdesc:a10ede603ade2ed4ff6d9c093edb53868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#aa37b401f2a0186e69738fe9c64f61dc0" title="A handle to the descriptorsetlayout created by backend in KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_...">KarmaGui_ImplVulkan_Data.DescriptorSetLayout</a> if not already in <a class="el" href="#a8798f337eabad2a1268cfbaa6114643c" title="Generates or creates the following objects.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDeviceObjects()</a>  <br /></td></tr>
<tr class="separator:a10ede603ade2ed4ff6d9c093edb53868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b7ac4443496f979c1532a8bd4a1a72" id="r_ab0b7ac4443496f979c1532a8bd4a1a72"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0b7ac4443496f979c1532a8bd4a1a72">KarmaGui_ImplVulkan_CreatePipelineLayout</a> (VkDevice device, const VkAllocationCallbacks *allocator)</td></tr>
<tr class="memdesc:ab0b7ac4443496f979c1532a8bd4a1a72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a0a98124a889feda82390bfe97e14e1b6" title="Opaque handle to a pipeline layout object. Access to descriptor sets from a pipeline is accomplished ...">KarmaGui_ImplVulkan_Data.PipelineLayout</a> (if not already in <a class="el" href="#a8798f337eabad2a1268cfbaa6114643c" title="Generates or creates the following objects.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDeviceObjects()</a>).  <br /></td></tr>
<tr class="separator:ab0b7ac4443496f979c1532a8bd4a1a72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb43f8c13ca81df044eecbe9dbd05630" id="r_aeb43f8c13ca81df044eecbe9dbd05630"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeb43f8c13ca81df044eecbe9dbd05630">KarmaGui_ImplVulkan_CreatePipeline</a> (VkDevice device, const VkAllocationCallbacks *allocator, VkPipelineCache pipelineCache, VkRenderPass renderPass, VkSampleCountFlagBits MSAASamples, VkPipeline *pipeline, uint32_t subpass)</td></tr>
<tr class="memdesc:aeb43f8c13ca81df044eecbe9dbd05630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data.Pipeline</a>.  <br /></td></tr>
<tr class="separator:aeb43f8c13ca81df044eecbe9dbd05630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bec71360e2fe60c4cea26dac3cf565" id="r_aa6bec71360e2fe60c4cea26dac3cf565"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6bec71360e2fe60c4cea26dac3cf565">KarmaGui_ImplVulkan_CreateWindow</a> (<a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *viewport)</td></tr>
<tr class="memdesc:aa6bec71360e2fe60c4cea26dac3cf565"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an <em>advanced</em> and <em>optional</em> feature, allowing the backend to create and handle multiple viewports simultaneously. NOT SUPPORTED.  <br /></td></tr>
<tr class="separator:aa6bec71360e2fe60c4cea26dac3cf565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42881b7018110e014a12ce23d329da65" id="r_a42881b7018110e014a12ce23d329da65"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42881b7018110e014a12ce23d329da65">KarmaGui_ImplVulkan_DestroyWindow</a> (<a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *viewport)</td></tr>
<tr class="memdesc:a42881b7018110e014a12ce23d329da65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> window relevant data (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___viewport_data.html" title="Data relevant to rendering of a Mesa viewport.">KarmaGui_ImplVulkan_ViewportData</a>) and buffers. Basically set to KarmaGuiPlatformIO::Renderer_DestroyWindow pointer.  <br /></td></tr>
<tr class="separator:a42881b7018110e014a12ce23d329da65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab8fcd5e37558658567a97fc27d9e32" id="r_a4ab8fcd5e37558658567a97fc27d9e32"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ab8fcd5e37558658567a97fc27d9e32">KarmaGui_ImplVulkan_DestroyWindow</a> (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *windowData)</td></tr>
<tr class="memdesc:a4ab8fcd5e37558658567a97fc27d9e32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> window relevant data (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___viewport_data.html" title="Data relevant to rendering of a Mesa viewport.">KarmaGui_ImplVulkan_ViewportData</a>) and buffers. Called by <a class="el" href="class_karma_1_1_karma_gui_renderer.html#a775ef054881cb12eb9d06de979767828" title="Cleaning up vulkan allocated resources.">KarmaGuiRenderer::CleanUpVulkanAndWindowData()</a>  <br /></td></tr>
<tr class="separator:a4ab8fcd5e37558658567a97fc27d9e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fe945584a8c6cc1b93cce469ea71961" id="r_a2fe945584a8c6cc1b93cce469ea71961"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fe945584a8c6cc1b93cce469ea71961">KarmaGui_ImplVulkan_SetWindowSize</a> (<a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *viewport, <a class="el" href="struct_k_g_vec2.html">KGVec2</a> size)</td></tr>
<tr class="memdesc:a2fe945584a8c6cc1b93cce469ea71961"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of window rendering relevant resources (swapchain, framebuffers, and all that). Basically implementation of <a class="el" href="struct_karma_gui_platform_i_o.html#aa283022b931f333a1db0a0665a81fed4" title="Resize swap chain, frame buffers etc. (called after Platform_SetWindowSize)">KarmaGuiPlatformIO::Renderer_SetWindowSize</a>.  <br /></td></tr>
<tr class="separator:a2fe945584a8c6cc1b93cce469ea71961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b73653d18fdde91d1225e63abf9313" id="r_a72b73653d18fdde91d1225e63abf9313"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72b73653d18fdde91d1225e63abf9313">KarmaGui_ImplVulkan_RenderWindow</a> (<a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *viewport, void *)</td></tr>
<tr class="memdesc:a72b73653d18fdde91d1225e63abf9313"><td class="mdescLeft">&#160;</td><td class="mdescRight">A set of instructions for rendering a viewport of <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> window (called each loop for realtime Vulkan rendering). A bird's eye overview can be experienced in the wikipedia page <a href="https://github.com/ravimohan1991/KarmaEngine/wiki/Vulkan-Creative-Pipeline-(vCP)-II">https://github.com/ravimohan1991/KarmaEngine/wiki/Vulkan-Creative-Pipeline-(vCP)-II</a>. Set to <a class="el" href="struct_karma_gui_platform_i_o.html#a5889d84187c6addf5d6999efba728db2" title="(Optional) Clear framebuffer, setup render target, then render the viewport-&gt;DrawData....">KarmaGuiPlatformIO::Renderer_RenderWindow</a> in the function <a class="el" href="#aedb50322002e6ad8e1eb8e18356adb50" title="Called in KarmaGuiRenderer::KarmaGui_ImplVulkan_Init, during the initialization of Vulkan backend for...">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_InitPlatformInterface()</a>. Called in the routine KarmaGuiRenderer::OnKarmaGuiLayerEnd(), via <a class="el" href="class_karma_1_1_karma_gui.html#a4cfd4ebcfdaaec822b80b7805d288e36" title="Call in main loop. Will call RenderWindow/SwapBuffers platform functions for each secondary viewport ...">KarmaGui::RenderPlatformWindowsDefault()</a>-&gt;platform_io.Renderer_RenderWindow, if multiviewports (KGGuiConfigFlags_ViewportsEnable) are supported.  <br /></td></tr>
<tr class="separator:a72b73653d18fdde91d1225e63abf9313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca6554d0fac593aae7be85c39dab4b7" id="r_a2ca6554d0fac593aae7be85c39dab4b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ca6554d0fac593aae7be85c39dab4b7">KarmaGui_ImplVulkan_RenderDrawData</a> (<a class="el" href="struct_k_g_draw_data.html">KGDrawData</a> *drawData, VkCommandBuffer commandBuffer, VkPipeline pipeline, uint32_t imageFrameIndex)</td></tr>
<tr class="memdesc:a2ca6554d0fac593aae7be85c39dab4b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> primitives into command buffer. Frame rendering relevant buffers and resources are set. They include:  <br /></td></tr>
<tr class="separator:a2ca6554d0fac593aae7be85c39dab4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a73f7f1e709e8615bff7dc1e5aa00a" id="r_a00a73f7f1e709e8615bff7dc1e5aa00a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00a73f7f1e709e8615bff7dc1e5aa00a">KarmaGui_ImplVulkan_SwapBuffers</a> (<a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *viewport, void *)</td></tr>
<tr class="memdesc:a00a73f7f1e709e8615bff7dc1e5aa00a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called in KarmaGui_ImplVulkan_InitPlatformInterface for setting the field <a class="el" href="struct_karma_gui_platform_i_o.html#a4ec5324e8fa2e131a51fd0f38e6d33bc" title="(Optional) Call Present/SwapBuffers. &#39;render_arg&#39; is the value passed to Karma::KarmaGui::RenderPlatf...">KarmaGuiPlatformIO::Renderer_SwapBuffers</a>. Based upon the present conditions, does the following.  <br /></td></tr>
<tr class="separator:a00a73f7f1e709e8615bff7dc1e5aa00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c93fab4bd1c3b354b46485db32a8d6" id="r_ac2c93fab4bd1c3b354b46485db32a8d6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2c93fab4bd1c3b354b46485db32a8d6">ShareVulkanContextResourcesOfMainWindow</a> (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *windowData, bool bCreateSyncronicity=false)</td></tr>
<tr class="memdesc:ac2c93fab4bd1c3b354b46485db32a8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The purpose of the routine is two-fold.  <br /></td></tr>
<tr class="separator:ac2c93fab4bd1c3b354b46485db32a8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d00e6e1c2ed243be58dba5ce7ce26a6" id="r_a1d00e6e1c2ed243be58dba5ce7ce26a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d00e6e1c2ed243be58dba5ce7ce26a6">ClearVulkanWindowData</a> (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *vulkanWindowData, bool bDestroySyncronicity=false)</td></tr>
<tr class="memdesc:a1d00e6e1c2ed243be58dba5ce7ce26a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears appropriate buffers which are used for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>'s rendering. They include:  <br /></td></tr>
<tr class="separator:a1d00e6e1c2ed243be58dba5ce7ce26a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94070041ba2361045f0f8ea9ef3bf1e5" id="r_a94070041ba2361045f0f8ea9ef3bf1e5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94070041ba2361045f0f8ea9ef3bf1e5">DestroyWindowDataFrame</a> (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html">KarmaGui_ImplVulkanH_ImageFrame</a> *frame)</td></tr>
<tr class="memdesc:a94070041ba2361045f0f8ea9ef3bf1e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears KarmaGui_ImplVulkanH_ImageFrame::BackBuffer and <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html#ae6ab5c377d34dfdd1667da4b95c5f28e" title="A handle to framebuffer which represents a collection of specific memory attachments that a render pa...">KarmaGui_ImplVulkanH_ImageFrame::Framebuffer</a> and called by <a class="el" href="#a1d00e6e1c2ed243be58dba5ce7ce26a6" title="Clears appropriate buffers which are used for KarmaGui&#39;s rendering. They include:">KarmaGuiVulkanHandler::ClearVulkanWindowData</a>.  <br /></td></tr>
<tr class="separator:a94070041ba2361045f0f8ea9ef3bf1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b96ddbdae784e186e14f16357be59e" id="r_a84b96ddbdae784e186e14f16357be59e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84b96ddbdae784e186e14f16357be59e">DestroyFramesOnFlightData</a> (<a class="el" href="struct_karma_1_1_karma_gui___vulkan___frame___on___flight.html">KarmaGui_Vulkan_Frame_On_Flight</a> *frameSyncronicityData)</td></tr>
<tr class="memdesc:a84b96ddbdae784e186e14f16357be59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears all the synchronization primitives (semaphores and fences) associated with the rendering.  <br /></td></tr>
<tr class="separator:a84b96ddbdae784e186e14f16357be59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8565ba0b84ee6611092898b9a94d2d" id="r_aee8565ba0b84ee6611092898b9a94d2d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee8565ba0b84ee6611092898b9a94d2d">KarmaGui_ImplVulkan_CreateOrResizeWindow</a> (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *windowData, bool bCreateSyncronicity, bool bRecreateSwapChainAndCommandBuffers)</td></tr>
<tr class="memdesc:aee8565ba0b84ee6611092898b9a94d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">KarmaGui_ImplVulkan_CreateOrResizeWindow.  <br /></td></tr>
<tr class="separator:aee8565ba0b84ee6611092898b9a94d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2601ed7116d9c42c98d5c9c62146fe00" id="r_a2601ed7116d9c42c98d5c9c62146fe00"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2601ed7116d9c42c98d5c9c62146fe00">KarmaGui_ImplVulkan_DestroyAllViewportsRenderBuffers</a> (VkDevice device, const VkAllocationCallbacks *allocator)</td></tr>
<tr class="memdesc:a2601ed7116d9c42c98d5c9c62146fe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___viewport_data.html#ad561589b3551dd85139bfaf629b960f0" title="The rendering relevant buffers to be used by viewport.">KarmaGui_ImplVulkan_ViewportData::RenderBuffers</a> associated with the single <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> viewport.  <br /></td></tr>
<tr class="separator:a2601ed7116d9c42c98d5c9c62146fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fcca8d4decb19e46348685131ee6dc" id="r_af0fcca8d4decb19e46348685131ee6dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0fcca8d4decb19e46348685131ee6dc">KarmaGui_ImplVulkan_ShivaWindowRenderBuffers</a> (VkDevice device, <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window_render_buffers.html">KarmaGui_ImplVulkanH_WindowRenderBuffers</a> *buffers, const VkAllocationCallbacks *allocator)</td></tr>
<tr class="memdesc:af0fcca8d4decb19e46348685131ee6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and clears the frame buffers, <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window_render_buffers.html#a2b0dc6dd76f73e641d9a5616289d31a0" title="Reusable buffers used for rendering, to be instantiated.">KarmaGui_ImplVulkanH_WindowRenderBuffers::FrameRenderBuffers</a>, using KarmaGui_ImplVulkan_ShivaFrameRenderBuffers.  <br /></td></tr>
<tr class="separator:af0fcca8d4decb19e46348685131ee6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0a1ac0b54a0b7ce3896636d75a78c4" id="r_a3f0a1ac0b54a0b7ce3896636d75a78c4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f0a1ac0b54a0b7ce3896636d75a78c4">KarmaGui_ImplVulkan_ShivaFrameRenderBuffers</a> (VkDevice device, <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers</a> *buffers, const VkAllocationCallbacks *allocator)</td></tr>
<tr class="memdesc:a3f0a1ac0b54a0b7ce3896636d75a78c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys and clears the following buffers.  <br /></td></tr>
<tr class="separator:a3f0a1ac0b54a0b7ce3896636d75a78c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947289d89dbaaaf49ebe72b2a834d9d7" id="r_a947289d89dbaaaf49ebe72b2a834d9d7"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a947289d89dbaaaf49ebe72b2a834d9d7">KarmaGui_ImplVulkan_CreateFontsTexture</a> (VkCommandBuffer commandBuffer)</td></tr>
<tr class="memdesc:a947289d89dbaaaf49ebe72b2a834d9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates fonts' texture for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>.  <br /></td></tr>
<tr class="separator:a947289d89dbaaaf49ebe72b2a834d9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218401e00f91c8083613f52f3b3016fa" id="r_a218401e00f91c8083613f52f3b3016fa"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a218401e00f91c8083613f52f3b3016fa">KarmaGui_ImplVulkan_CreateTexture</a> (VkCommandBuffer commandBuffer, char const *fileName, const std::string &amp;lable=&quot;&quot;)</td></tr>
<tr class="memdesc:a218401e00f91c8083613f52f3b3016fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Routine to create Image vulkan texture.  <br /></td></tr>
<tr class="separator:a218401e00f91c8083613f52f3b3016fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8798f337eabad2a1268cfbaa6114643c" id="r_a8798f337eabad2a1268cfbaa6114643c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8798f337eabad2a1268cfbaa6114643c">KarmaGui_ImplVulkan_CreateDeviceObjects</a> ()</td></tr>
<tr class="memdesc:a8798f337eabad2a1268cfbaa6114643c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates or creates the following objects.  <br /></td></tr>
<tr class="separator:a8798f337eabad2a1268cfbaa6114643c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3277122d232fe6a9bb2f8f8df477a" id="r_ab0c3277122d232fe6a9bb2f8f8df477a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0c3277122d232fe6a9bb2f8f8df477a">KarmaGui_ImplVulkan_DestroyFontUploadObjects</a> ()</td></tr>
<tr class="memdesc:ab0c3277122d232fe6a9bb2f8f8df477a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to destroy the fonts (created by <a class="el" href="#a947289d89dbaaaf49ebe72b2a834d9d7" title="Creates fonts&#39; texture for KarmaGui.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateFontsTexture</a>) by clearing the following buffers.  <br /></td></tr>
<tr class="separator:ab0c3277122d232fe6a9bb2f8f8df477a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1474726a454ef471ef767f903f5551da" id="r_a1474726a454ef471ef767f903f5551da"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1474726a454ef471ef767f903f5551da">KarmaGui_ImplVulkan_DestroyDeviceObjects</a> ()</td></tr>
<tr class="memdesc:a1474726a454ef471ef767f903f5551da"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following objects are destroyed.  <br /></td></tr>
<tr class="separator:a1474726a454ef471ef767f903f5551da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8f9c6e2dcc1f47adc41ed6f55370d9" id="r_a4e8f9c6e2dcc1f47adc41ed6f55370d9"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e8f9c6e2dcc1f47adc41ed6f55370d9">KarmaGui_ImplVulkan_Shutdown</a> ()</td></tr>
<tr class="memdesc:a4e8f9c6e2dcc1f47adc41ed6f55370d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called in the KarmaGuiRenderer::GracefulVulkanShutDown(). Basically does the following.  <br /></td></tr>
<tr class="separator:a4e8f9c6e2dcc1f47adc41ed6f55370d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff694292f77f635db29dd1804c13bda" id="r_a4ff694292f77f635db29dd1804c13bda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ff694292f77f635db29dd1804c13bda">KarmaGui_ImplVulkan_NewFrame</a> ()</td></tr>
<tr class="memdesc:a4ff694292f77f635db29dd1804c13bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">No clue what this does. Legacy?  <br /></td></tr>
<tr class="separator:a4ff694292f77f635db29dd1804c13bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69593647c6b97022deb5449e94bdef93" id="r_a69593647c6b97022deb5449e94bdef93"><td class="memItemLeft" align="right" valign="top">static VkDescriptorSet&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69593647c6b97022deb5449e94bdef93">KarmaGui_ImplVulkan_AddTexture</a> (VkSampler sampler, VkImageView imageView, VkImageLayout imageLayout)</td></tr>
<tr class="memdesc:a69593647c6b97022deb5449e94bdef93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a texture by creation of descriptor set from preallocated descriptor pool.  <br /></td></tr>
<tr class="separator:a69593647c6b97022deb5449e94bdef93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb50322002e6ad8e1eb8e18356adb50" id="r_aedb50322002e6ad8e1eb8e18356adb50"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedb50322002e6ad8e1eb8e18356adb50">KarmaGui_ImplVulkan_InitPlatformInterface</a> ()</td></tr>
<tr class="memdesc:aedb50322002e6ad8e1eb8e18356adb50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called in <a class="el" href="class_karma_1_1_karma_gui_renderer.html#a9b480e660f6873323cbdc9b93c3d2211" title="Initialize Vulkan backend renderer.">KarmaGuiRenderer::KarmaGui_ImplVulkan_Init</a>, during the initialization of Vulkan backend for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>, if Vulkan is the chosen renderer (<a class="el" href="class_karma_1_1_renderer_a_p_i.html#a2e92f9cf14b27dae03f2d5f360af98d3" title="Getter for rendering api being used.">RendererAPI::GetAPI()</a> == <a class="el" href="class_karma_1_1_renderer_a_p_i.html#a573e3e054970498200c116a853602934a38625270231b647116c80bcbc4f9d1d8" title="Vulkan (https://www.vulkan.org)">RendererAPI::API::Vulkan</a>).  <br /></td></tr>
<tr class="separator:aedb50322002e6ad8e1eb8e18356adb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef31ff42b26af3f3f9b7b348ca304f42" id="r_aef31ff42b26af3f3f9b7b348ca304f42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef31ff42b26af3f3f9b7b348ca304f42">KarmaGui_ImplVulkan_ShutdownPlatformInterface</a> ()</td></tr>
<tr class="memdesc:aef31ff42b26af3f3f9b7b348ca304f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls KarmaGui::DestroyPlatformWindows, which further calls KarmaGuiInternal::DestroyPlatformWindow on each viewport window (main viewport in current state). Clears the RendererUserData and calls <a class="el" href="#a42881b7018110e014a12ce23d329da65" title="Destroys the KarmaGui window relevant data (KarmaGui_ImplVulkan_ViewportData) and buffers....">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyWindow</a>.  <br /></td></tr>
<tr class="separator:aef31ff42b26af3f3f9b7b348ca304f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class for required Vulkan routines for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> Vulkan backend. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a1d00e6e1c2ed243be58dba5ce7ce26a6" name="a1d00e6e1c2ed243be58dba5ce7ce26a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d00e6e1c2ed243be58dba5ce7ce26a6">&#9670;&#160;</a></span>ClearVulkanWindowData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::ClearVulkanWindowData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *</td>          <td class="paramname"><span class="paramname"><em>vulkanWindowData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bDestroySyncronicity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears appropriate buffers which are used for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>'s rendering. They include: </p>
<ul>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html#a827c0cf1d334104bdb429ca3030afd76" title="Just a container for buffers and all those sizes depending on VulkanHolder::GetVulkanContext()-&gt;GetSw...">KarmaGui_ImplVulkanH_Window::ImageFrames</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html#a4e83a6e76e046beb3704892784f58fc3" title="Data for synchronous operations of in-flight rendering frames.">KarmaGui_ImplVulkanH_Window::FramesOnFlight</a> if bDestroySyncronicity is set to true</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vulkanWindowData</td><td>The datastructure containing the buffers to be cleared </td></tr>
    <tr><td class="paramname">bDestroySyncronicity</td><td>FramesOnFlight buffers are cleared if set to true, for instance <a class="el" href="#a42881b7018110e014a12ce23d329da65" title="Destroys the KarmaGui window relevant data (KarmaGui_ImplVulkan_ViewportData) and buffers....">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyWindow</a>. Else, when set to false, for instance swapchain is recreated and similar things in KarmaGuiRenderer::GiveLoopBeginControlToVulkan (see KarmaGuiVulkanHandler::ShareVulkanContextResourcesOfMainWindow(&amp;m_VulkanWindowData, false)), they aren't touched.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a56fe3b6d98631be363c0d4a3990c4b8f" name="a56fe3b6d98631be363c0d4a3990c4b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fe3b6d98631be363c0d4a3990c4b8f">&#9670;&#160;</a></span>CreateOrResizeBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::CreateOrResizeBuffer </td>
          <td>(</td>
          <td class="paramtype">VkBuffer &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceMemory &amp;</td>          <td class="paramname"><span class="paramname"><em>bufferMemory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkDeviceSize &amp;</td>          <td class="paramname"><span class="paramname"><em>pBufferSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>newSize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkBufferUsageFlagBits</td>          <td class="paramname"><span class="paramname"><em>usage</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates new vulkan buffer and allocates appropriate memory based upon the supplied newSize (appropriately aligned) and usage. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The vulkan buffer to be resized </td></tr>
    <tr><td class="paramname">bufferMemory</td><td>The device memory to be used for buffer </td></tr>
    <tr><td class="paramname">pBufferSize</td><td>The size, in bytes, of the memory resource alloted to the buffer </td></tr>
    <tr><td class="paramname">newSize</td><td>The (could be unaligned?) size, in bytes, of the buffer to be created </td></tr>
    <tr><td class="paramname">usage</td><td>This is a bitmask of VkBufferUsageFlagBits specifying allowed usages of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If supplied buffer and bufferMemory are not null, then they are destroyed. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a84b96ddbdae784e186e14f16357be59e" name="a84b96ddbdae784e186e14f16357be59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84b96ddbdae784e186e14f16357be59e">&#9670;&#160;</a></span>DestroyFramesOnFlightData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::DestroyFramesOnFlightData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___vulkan___frame___on___flight.html">KarmaGui_Vulkan_Frame_On_Flight</a> *</td>          <td class="paramname"><span class="paramname"><em>frameSyncronicityData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears all the synchronization primitives (semaphores and fences) associated with the rendering. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frameSyncronicityData</td><td>The pointer to datastructure object holding rendering relevant syncronicity data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a94070041ba2361045f0f8ea9ef3bf1e5" name="a94070041ba2361045f0f8ea9ef3bf1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94070041ba2361045f0f8ea9ef3bf1e5">&#9670;&#160;</a></span>DestroyWindowDataFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::DestroyWindowDataFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html">KarmaGui_ImplVulkanH_ImageFrame</a> *</td>          <td class="paramname"><span class="paramname"><em>frame</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears KarmaGui_ImplVulkanH_ImageFrame::BackBuffer and <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html#ae6ab5c377d34dfdd1667da4b95c5f28e" title="A handle to framebuffer which represents a collection of specific memory attachments that a render pa...">KarmaGui_ImplVulkanH_ImageFrame::Framebuffer</a> and called by <a class="el" href="#a1d00e6e1c2ed243be58dba5ce7ce26a6" title="Clears appropriate buffers which are used for KarmaGui&#39;s rendering. They include:">KarmaGuiVulkanHandler::ClearVulkanWindowData</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frame</td><td>The ImageFrame data to be cleared </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a69593647c6b97022deb5449e94bdef93" name="a69593647c6b97022deb5449e94bdef93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69593647c6b97022deb5449e94bdef93">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_AddTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VkDescriptorSet Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_AddTexture </td>
          <td>(</td>
          <td class="paramtype">VkSampler</td>          <td class="paramname"><span class="paramname"><em>sampler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageView</td>          <td class="paramname"><span class="paramname"><em>imageView</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkImageLayout</td>          <td class="paramname"><span class="paramname"><em>imageLayout</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Register a texture by creation of descriptor set from preallocated descriptor pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampler</td><td>The sampler handle used in descriptor updates for type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER if the binding being updated does not use immutable samplers. </td></tr>
    <tr><td class="paramname">imageView</td><td>An image view handle, and is used in descriptor updates for type VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER. The image view representing contiguous ranges of the image subresources and containing additional metadata which are used by pipeline shaders for reading or writing image data. </td></tr>
    <tr><td class="paramname">imageLayout</td><td>The layout that the image subresources accessible from imageView will be in at the time this descriptor is accessed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a10ede603ade2ed4ff6d9c093edb53868" name="a10ede603ade2ed4ff6d9c093edb53868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ede603ade2ed4ff6d9c093edb53868">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateDescriptorSetLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDescriptorSetLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#aa37b401f2a0186e69738fe9c64f61dc0" title="A handle to the descriptorsetlayout created by backend in KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_...">KarmaGui_ImplVulkan_Data.DescriptorSetLayout</a> if not already in <a class="el" href="#a8798f337eabad2a1268cfbaa6114643c" title="Generates or creates the following objects.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDeviceObjects()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device handle. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ac22663acc56381a44ad59eac1e159276" title="A logical device handle. Device is an appropriate instance using which swapchains,...">KarmaGui_ImplVulkan_InitInfo::Device</a> </td></tr>
    <tr><td class="paramname">allocator</td><td>The controller of host memory allocation as described in the Memory Allocation chapter. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#acb44f9a1a46c09a6244eb2ddcb57f0c4" title="A pointer to a valid VkAllocationCallbacks structure. Structure containing callback function pointers...">KarmaGui_ImplVulkan_InitInfo.Allocator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a8798f337eabad2a1268cfbaa6114643c" name="a8798f337eabad2a1268cfbaa6114643c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8798f337eabad2a1268cfbaa6114643c">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateDeviceObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDeviceObjects </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates or creates the following objects. </p>
<ol type="1">
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a1176bcb25813c28c571cee1d682fe36a" title="Opaque handle to a sampler object. The object represents the state of an image sampler which is used ...">KarmaGui_ImplVulkan_Data::FontSampler</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#aa37b401f2a0186e69738fe9c64f61dc0" title="A handle to the descriptorsetlayout created by backend in KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_...">KarmaGui_ImplVulkan_Data::DescriptorSetLayout</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a0a98124a889feda82390bfe97e14e1b6" title="Opaque handle to a pipeline layout object. Access to descriptor sets from a pipeline is accomplished ...">KarmaGui_ImplVulkan_Data::PipelineLayout</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data::Pipeline</a></li>
</ol>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aa583f5e1a61b93581443dc2382056da6" name="aa583f5e1a61b93581443dc2382056da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa583f5e1a61b93581443dc2382056da6">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateFontSampler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateFontSampler </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bilinear sampling object is created for font and stored in <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a1176bcb25813c28c571cee1d682fe36a" title="Opaque handle to a sampler object. The object represents the state of an image sampler which is used ...">KarmaGui_ImplVulkan_Data.FontSampler</a> if not done already in <a class="el" href="#a8798f337eabad2a1268cfbaa6114643c" title="Generates or creates the following objects.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDeviceObjects()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device handle. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ac22663acc56381a44ad59eac1e159276" title="A logical device handle. Device is an appropriate instance using which swapchains,...">KarmaGui_ImplVulkan_InitInfo::Device</a> </td></tr>
    <tr><td class="paramname">allocator</td><td>The controller of host memory allocation as described in the Memory Allocation chapter. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#acb44f9a1a46c09a6244eb2ddcb57f0c4" title="A pointer to a valid VkAllocationCallbacks structure. Structure containing callback function pointers...">KarmaGui_ImplVulkan_InitInfo.Allocator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a947289d89dbaaaf49ebe72b2a834d9d7" name="a947289d89dbaaaf49ebe72b2a834d9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947289d89dbaaaf49ebe72b2a834d9d7">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateFontsTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateFontsTexture </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer</td>          <td class="paramname"><span class="paramname"><em>commandBuffer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates fonts' texture for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The buffer of commands to be filled with primitive drawing and relevant commands </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aee8565ba0b84ee6611092898b9a94d2d" name="aee8565ba0b84ee6611092898b9a94d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8565ba0b84ee6611092898b9a94d2d">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateOrResizeWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateOrResizeWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *</td>          <td class="paramname"><span class="paramname"><em>windowData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bCreateSyncronicity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bRecreateSwapChainAndCommandBuffers</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>KarmaGui_ImplVulkan_CreateOrResizeWindow. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowData</td><td>The datastructure object containing the buffers to be manipulated </td></tr>
    <tr><td class="paramname">bCreateSyncronicity</td><td><br  />
 </td></tr>
    <tr><td class="paramname">bRecreateSwapChainAndCommandBuffers</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aeb43f8c13ca81df044eecbe9dbd05630" name="aeb43f8c13ca81df044eecbe9dbd05630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb43f8c13ca81df044eecbe9dbd05630">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreatePipeline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreatePipeline </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipelineCache</td>          <td class="paramname"><span class="paramname"><em>pipelineCache</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkRenderPass</td>          <td class="paramname"><span class="paramname"><em>renderPass</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkSampleCountFlagBits</td>          <td class="paramname"><span class="paramname"><em>MSAASamples</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline *</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>subpass</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data.Pipeline</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device handle. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ac22663acc56381a44ad59eac1e159276" title="A logical device handle. Device is an appropriate instance using which swapchains,...">KarmaGui_ImplVulkan_InitInfo.Device</a> </td></tr>
    <tr><td class="paramname">allocator</td><td>The controller of host memory allocation as described in the Memory Allocation chapter. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#acb44f9a1a46c09a6244eb2ddcb57f0c4" title="A pointer to a valid VkAllocationCallbacks structure. Structure containing callback function pointers...">KarmaGui_ImplVulkan_InitInfo.Allocator</a> </td></tr>
    <tr><td class="paramname">pipelineCache</td><td>Usually this cache (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#a041d1b82cf53cb9649182f7111240b1d" title="Usually this cache is set to VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the han...">KarmaGui_ImplVulkan_InitInfo.PipelineCache</a>) is set to VK_NULL_HANDLE, indicating that pipeline caching is disabled; or the handle of a valid pipeline cache object, in which case use of that cache is enabled for the duration of the command. </td></tr>
    <tr><td class="paramname">renderPass</td><td>A render pass object (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ad7acd46e22b833a08e8bc3abc2c4ac13" title="A render pass object represents a collection of attachments, subpasses, and dependencies between the ...">KarmaGui_ImplVulkan_Data.RenderPass</a>) represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses. </td></tr>
    <tr><td class="paramname">MSAASamples</td><td><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#aa666b8f96e225b0935fbac0f2db00ef6" title="Is a VkSampleCountFlagBits value specifying the number of samples used in rasterization....">KarmaGui_ImplVulkan_InitInfo::MSAASamples</a> </td></tr>
    <tr><td class="paramname">pipeline</td><td><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data::Pipeline</a> </td></tr>
    <tr><td class="paramname">subpass</td><td>KarmaGui_ImplVulkan_Data::subpass</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ab0b7ac4443496f979c1532a8bd4a1a72" name="ab0b7ac4443496f979c1532a8bd4a1a72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b7ac4443496f979c1532a8bd4a1a72">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreatePipelineLayout()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreatePipelineLayout </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a0a98124a889feda82390bfe97e14e1b6" title="Opaque handle to a pipeline layout object. Access to descriptor sets from a pipeline is accomplished ...">KarmaGui_ImplVulkan_Data.PipelineLayout</a> (if not already in <a class="el" href="#a8798f337eabad2a1268cfbaa6114643c" title="Generates or creates the following objects.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateDeviceObjects()</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device handle. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ac22663acc56381a44ad59eac1e159276" title="A logical device handle. Device is an appropriate instance using which swapchains,...">KarmaGui_ImplVulkan_InitInfo::Device</a> </td></tr>
    <tr><td class="paramname">allocator</td><td>The controller of host memory allocation as described in the Memory Allocation chapter. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#acb44f9a1a46c09a6244eb2ddcb57f0c4" title="A pointer to a valid VkAllocationCallbacks structure. Structure containing callback function pointers...">KarmaGui_ImplVulkan_InitInfo.Allocator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="abd34e93e2175ac37b4c01191aa77298b" name="abd34e93e2175ac37b4c01191aa77298b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd34e93e2175ac37b4c01191aa77298b">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateShaderModules()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateShaderModules </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to create the shader modules (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#aaa4f696be8c1c601fdb26abcbadc56a6" title="Opaque handle to a vertex shader module object for backend. Shader modules contain shader code and on...">KarmaGui_ImplVulkan_Data.ShaderModuleVert</a> and <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ac35e29609b5537b35dde85d6957a4456" title="Opaque handle to fragment shader module object for backend. Shader modules contain shader code and on...">KarmaGui_ImplVulkan_Data.ShaderModuleFrag</a>) for the backend GraphicsPipeline (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data.Pipeline</a>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device handle. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ac22663acc56381a44ad59eac1e159276" title="A logical device handle. Device is an appropriate instance using which swapchains,...">KarmaGui_ImplVulkan_InitInfo::Device</a> </td></tr>
    <tr><td class="paramname">allocator</td><td>The controller of host memory allocation as described in the Memory Allocation chapter. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#acb44f9a1a46c09a6244eb2ddcb57f0c4" title="A pointer to a valid VkAllocationCallbacks structure. Structure containing callback function pointers...">KarmaGui_ImplVulkan_InitInfo.Allocator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a218401e00f91c8083613f52f3b3016fa" name="a218401e00f91c8083613f52f3b3016fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218401e00f91c8083613f52f3b3016fa">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateTexture </td>
          <td>(</td>
          <td class="paramtype">VkCommandBuffer</td>          <td class="paramname"><span class="paramname"><em>commandBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>lable</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Routine to create Image vulkan texture. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>The buffer of commands to be filled with primitive drawing and relevant commands </td></tr>
    <tr><td class="paramname">fileName</td><td>The relative path to the file containing Image (for instance "../Resources/Textures/The_Source_Wall.jpg") </td></tr>
    <tr><td class="paramname">label</td><td>The texture lable for internal use or identification (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___image___texture_data.html#af6dbc03a6ec9eec30ce40e5aa2730f7c" title="The name of the image texture for Mesa.">KarmaGui_ImplVulkan_Image_TextureData::TextureLable</a>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aa6bec71360e2fe60c4cea26dac3cf565" name="aa6bec71360e2fe60c4cea26dac3cf565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6bec71360e2fe60c4cea26dac3cf565">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_CreateWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *</td>          <td class="paramname"><span class="paramname"><em>viewport</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is an <em>advanced</em> and <em>optional</em> feature, allowing the backend to create and handle multiple viewports simultaneously. NOT SUPPORTED. </p>
<dl class="section note"><dt>Note</dt><dd>Something to strive for? :) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a2601ed7116d9c42c98d5c9c62146fe00" name="a2601ed7116d9c42c98d5c9c62146fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2601ed7116d9c42c98d5c9c62146fe00">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_DestroyAllViewportsRenderBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyAllViewportsRenderBuffers </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___viewport_data.html#ad561589b3551dd85139bfaf629b960f0" title="The rendering relevant buffers to be used by viewport.">KarmaGui_ImplVulkan_ViewportData::RenderBuffers</a> associated with the single <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> viewport. </p>
<dl class="section note"><dt>Note</dt><dd>Engine is not supporting multiviewports in the current state.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a1474726a454ef471ef767f903f5551da" name="a1474726a454ef471ef767f903f5551da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1474726a454ef471ef767f903f5551da">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_DestroyDeviceObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyDeviceObjects </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following objects are destroyed. </p>
<ol type="1">
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#aaa4f696be8c1c601fdb26abcbadc56a6" title="Opaque handle to a vertex shader module object for backend. Shader modules contain shader code and on...">KarmaGui_ImplVulkan_Data::ShaderModuleVert</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ac35e29609b5537b35dde85d6957a4456" title="Opaque handle to fragment shader module object for backend. Shader modules contain shader code and on...">KarmaGui_ImplVulkan_Data::ShaderModuleFrag</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a822bfaaf08696e4a2447b0798f177da9" title="The image view, for 2D font, representing contiguous ranges of the image subresources and containing ...">KarmaGui_ImplVulkan_Data::FontView</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a199330d3989487cb2f5401c420ef17e6" title="A 2D font image object with following properties.">KarmaGui_ImplVulkan_Data::FontImage</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a5d89f7c1915f3d64f4576bbabc31ee97" title="The memory resource allocated for the fonts to be displayed by the backend.">KarmaGui_ImplVulkan_Data::FontMemory</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a1176bcb25813c28c571cee1d682fe36a" title="Opaque handle to a sampler object. The object represents the state of an image sampler which is used ...">KarmaGui_ImplVulkan_Data::FontSampler</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#aa37b401f2a0186e69738fe9c64f61dc0" title="A handle to the descriptorsetlayout created by backend in KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_...">KarmaGui_ImplVulkan_Data::DescriptorSetLayout</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a0a98124a889feda82390bfe97e14e1b6" title="Opaque handle to a pipeline layout object. Access to descriptor sets from a pipeline is accomplished ...">KarmaGui_ImplVulkan_Data::PipelineLayout</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data::Pipeline</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___image___texture_data.html" title="Data structure containing the Mesa image texture relevant data. For instance, file and folder icons o...">KarmaGui_ImplVulkan_Image_TextureData</a> of <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ac6e6b1a2bd4881e77346873d7611cd71" title="List of vulkan images&#39; textures, for instance icons and stuff.">KarmaGui_ImplVulkan_Data::vulkanMesaDecalDataList</a></li>
</ol>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ab0c3277122d232fe6a9bb2f8f8df477a" name="ab0c3277122d232fe6a9bb2f8f8df477a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c3277122d232fe6a9bb2f8f8df477a">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_DestroyFontUploadObjects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyFontUploadObjects </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function to destroy the fonts (created by <a class="el" href="#a947289d89dbaaaf49ebe72b2a834d9d7" title="Creates fonts&#39; texture for KarmaGui.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateFontsTexture</a>) by clearing the following buffers. </p>
<ol type="1">
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a8ccf521349eac9ed98b01e44d0c05827" title="Vulkan buffer containing font texture pixels.">KarmaGui_ImplVulkan_Data::UploadBuffer</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#a732d9dc8a242ef93961140cac8e66f27" title="Device allocated memory for font image pixels&#39; buffer.">KarmaGui_ImplVulkan_Data::UploadBufferMemory</a></li>
</ol>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a4ab8fcd5e37558658567a97fc27d9e32" name="a4ab8fcd5e37558658567a97fc27d9e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab8fcd5e37558658567a97fc27d9e32">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_DestroyWindow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *</td>          <td class="paramname"><span class="paramname"><em>windowData</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> window relevant data (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___viewport_data.html" title="Data relevant to rendering of a Mesa viewport.">KarmaGui_ImplVulkan_ViewportData</a>) and buffers. Called by <a class="el" href="class_karma_1_1_karma_gui_renderer.html#a775ef054881cb12eb9d06de979767828" title="Cleaning up vulkan allocated resources.">KarmaGuiRenderer::CleanUpVulkanAndWindowData()</a> </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a1d00e6e1c2ed243be58dba5ce7ce26a6" title="Clears appropriate buffers which are used for KarmaGui&#39;s rendering. They include:">KarmaGuiVulkanHandler::ClearVulkanWindowData</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowData</td><td>The vulkan context containing relevant data to be deallocated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a42881b7018110e014a12ce23d329da65" name="a42881b7018110e014a12ce23d329da65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42881b7018110e014a12ce23d329da65">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_DestroyWindow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *</td>          <td class="paramname"><span class="paramname"><em>viewport</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys the <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> window relevant data (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___viewport_data.html" title="Data relevant to rendering of a Mesa viewport.">KarmaGui_ImplVulkan_ViewportData</a>) and buffers. Basically set to KarmaGuiPlatformIO::Renderer_DestroyWindow pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The current platform window to be destroyed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aedb50322002e6ad8e1eb8e18356adb50" name="aedb50322002e6ad8e1eb8e18356adb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb50322002e6ad8e1eb8e18356adb50">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_InitPlatformInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_InitPlatformInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called in <a class="el" href="class_karma_1_1_karma_gui_renderer.html#a9b480e660f6873323cbdc9b93c3d2211" title="Initialize Vulkan backend renderer.">KarmaGuiRenderer::KarmaGui_ImplVulkan_Init</a>, during the initialization of Vulkan backend for <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>, if Vulkan is the chosen renderer (<a class="el" href="class_karma_1_1_renderer_a_p_i.html#a2e92f9cf14b27dae03f2d5f360af98d3" title="Getter for rendering api being used.">RendererAPI::GetAPI()</a> == <a class="el" href="class_karma_1_1_renderer_a_p_i.html#a573e3e054970498200c116a853602934a38625270231b647116c80bcbc4f9d1d8" title="Vulkan (https://www.vulkan.org)">RendererAPI::API::Vulkan</a>). </p>
<dl class="section note"><dt>Note</dt><dd>Setting up <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>'s window operations (create, resize, and all that)</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a19d9046ecead4192278f5f15dddcca51" name="a19d9046ecead4192278f5f15dddcca51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d9046ecead4192278f5f15dddcca51">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_MemoryType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_MemoryType </td>
          <td>(</td>
          <td class="paramtype">VkMemoryPropertyFlags</td>          <td class="paramname"><span class="paramname"><em>properties</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>type_bits</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reports memory relevant type information for the specified physical device (the GPU, represented by <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ad2473723d37a6a5ed216184210e01a27" title="The handle to the Vulkan&#39;s software representaion of GPU, for use in backend.">KarmaGui_ImplVulkan_InitInfo.PhysicalDevice</a>), based on supplied properties and type_bits (not exceeding a valid limit). </p>
<dl class="section note"><dt>Note</dt><dd>Device memory is memory that is visible to the device for example the contents of the image or buffer objects, which can be natively used by the device.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">properties</td><td>The memory properties to be queried. This is a bitmask type for setting a mask of zero or more VkMemoryPropertyFlagBits. </td></tr>
    <tr><td class="paramname">type_bits</td><td>This is a bitmask and contains one bit set for every supported memory type (obtained from vkGetBufferMemoryRequirements, for instance) for the resource. Bit i is set if and only if the memory type i in the VkPhysicalDeviceMemoryProperties structure for the physical device is supported for the resource.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the appropriate device memory type, else uint32_t(0xFFFFFFFF) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a4ff694292f77f635db29dd1804c13bda" name="a4ff694292f77f635db29dd1804c13bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff694292f77f635db29dd1804c13bda">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_NewFrame()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_NewFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No clue what this does. Legacy? </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000087">Todo</a></b></dt><dd>Ponder over </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a2ca6554d0fac593aae7be85c39dab4b7" name="a2ca6554d0fac593aae7be85c39dab4b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca6554d0fac593aae7be85c39dab4b7">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_RenderDrawData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_RenderDrawData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_k_g_draw_data.html">KGDrawData</a> *</td>          <td class="paramname"><span class="paramname"><em>drawData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer</td>          <td class="paramname"><span class="paramname"><em>commandBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>imageFrameIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Record <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> primitives into command buffer. Frame rendering relevant buffers and resources are set. They include: </p>
<ol type="1">
<li>drawData-&gt;OwnerViewport-&gt;RendererUserData-&gt;RenderBuffers (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___viewport_data.html#ad561589b3551dd85139bfaf629b960f0" title="The rendering relevant buffers to be used by viewport.">KarmaGui_ImplVulkan_ViewportData::RenderBuffers</a>)</li>
<li>drawData-&gt;OwnerViewport-&gt;RendererUserData-&gt;RenderBuffers-&gt;FrameRenderBuffers (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window_render_buffers.html#a2b0dc6dd76f73e641d9a5616289d31a0" title="Reusable buffers used for rendering, to be instantiated.">KarmaGui_ImplVulkanH_WindowRenderBuffers::FrameRenderBuffers</a>)</li>
<li>FrameRenderBuffers::VertexBuffer and FrameRenderBuffers::IndexBuffer and corresponding sizes</li>
<li>Commandbuffer is filled with scissor, KarmaGui_ImplVulkan_SetupRenderState, and drawing primitives commands</li>
</ol>
<p>Also any callback routines, usually related to rendering in <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>'s window (3D scene data atm), are processed here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawData</td><td>All draw data to render a <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> frame </td></tr>
    <tr><td class="paramname">commandBuffer</td><td>The buffer of commands to be filled with primitive drawing and relevant commands </td></tr>
    <tr><td class="paramname">pipeline</td><td><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___data.html#ab3fd538b7f67b6e1b6af2e36a9cafae9" title="A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw....">KarmaGui_ImplVulkan_Data::Pipeline</a> </td></tr>
    <tr><td class="paramname">imageFrameIndex</td><td>The frame counter (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html#a2434955c7533a2fea20d7acd813634e9" title="Current set of swapchain wait semaphores and command buffers we&#39;re using (0 &lt;= SemaphoreIndex &lt; MAX_F...">KarmaGui_ImplVulkanH_Window::SemaphoreIndex</a>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Called by KarmaGuiRenderer::FrameRender between vkCmdBeginRenderPass and vkCmdEndRenderPass like so <div class="fragment"><div class="line">vkCmdBeginRenderPass(frameOnFlightData-&gt;CommandBuffer, &amp;renderPassInfo, VK_SUBPASS_CONTENTS_INLINE);</div>
<div class="line">{</div>
<div class="line"> <span class="comment">// Record KarmaGui primitives into command buffer</span></div>
<div class="line"> <a class="code hl_function" href="#a2ca6554d0fac593aae7be85c39dab4b7">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_RenderDrawData</a>(drawData, frameOnFlightData-&gt;CommandBuffer, VK_NULL_HANDLE, windowData-&gt;SemaphoreIndex);</div>
<div class="line">}</div>
<div class="line">vkCmdEndRenderPass(frameOnFlightData-&gt;CommandBuffer);</div>
<div class="ttc" id="aclass_karma_1_1_karma_gui_vulkan_handler_html_a2ca6554d0fac593aae7be85c39dab4b7"><div class="ttname"><a href="#a2ca6554d0fac593aae7be85c39dab4b7">Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_RenderDrawData</a></div><div class="ttdeci">static void KarmaGui_ImplVulkan_RenderDrawData(KGDrawData *drawData, VkCommandBuffer commandBuffer, VkPipeline pipeline, uint32_t imageFrameIndex)</div><div class="ttdoc">Record KarmaGui primitives into command buffer. Frame rendering relevant buffers and resources are se...</div><div class="ttdef"><b>Definition</b> KarmaGuiVulkanHandler.cpp:239</div></div>
</div><!-- fragment --></dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a72b73653d18fdde91d1225e63abf9313" name="a72b73653d18fdde91d1225e63abf9313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b73653d18fdde91d1225e63abf9313">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_RenderWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_RenderWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *</td>          <td class="paramname"><span class="paramname"><em>viewport</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A set of instructions for rendering a viewport of <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> window (called each loop for realtime Vulkan rendering). A bird's eye overview can be experienced in the wikipedia page <a href="https://github.com/ravimohan1991/KarmaEngine/wiki/Vulkan-Creative-Pipeline-(vCP)-II">https://github.com/ravimohan1991/KarmaEngine/wiki/Vulkan-Creative-Pipeline-(vCP)-II</a>. Set to <a class="el" href="struct_karma_gui_platform_i_o.html#a5889d84187c6addf5d6999efba728db2" title="(Optional) Clear framebuffer, setup render target, then render the viewport-&gt;DrawData....">KarmaGuiPlatformIO::Renderer_RenderWindow</a> in the function <a class="el" href="#aedb50322002e6ad8e1eb8e18356adb50" title="Called in KarmaGuiRenderer::KarmaGui_ImplVulkan_Init, during the initialization of Vulkan backend for...">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_InitPlatformInterface()</a>. Called in the routine KarmaGuiRenderer::OnKarmaGuiLayerEnd(), via <a class="el" href="class_karma_1_1_karma_gui.html#a4cfd4ebcfdaaec822b80b7805d288e36" title="Call in main loop. Will call RenderWindow/SwapBuffers platform functions for each secondary viewport ...">KarmaGui::RenderPlatformWindowsDefault()</a>-&gt;platform_io.Renderer_RenderWindow, if multiviewports (KGGuiConfigFlags_ViewportsEnable) are supported. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The viewport to be rendered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Engine is not supporting multiviewports in the current state. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ac989f0dd29c02b3489ff33a31c0b261b" name="ac989f0dd29c02b3489ff33a31c0b261b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac989f0dd29c02b3489ff33a31c0b261b">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_SetupRenderState()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_SetupRenderState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_k_g_draw_data.html">KGDrawData</a> *</td>          <td class="paramname"><span class="paramname"><em>drawData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkPipeline</td>          <td class="paramname"><span class="paramname"><em>pipeline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer</td>          <td class="paramname"><span class="paramname"><em>commandBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers</a> *</td>          <td class="paramname"><span class="paramname"><em>remderingBufferData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to bind index/vertex buffers, setup a external viewport, and bind pipeline. Usually for rendering of <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> windows and all that. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawData</td><td>All draw data to render a <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> frame </td></tr>
    <tr><td class="paramname">pipeline</td><td>The vulkan pipeline (created in KarmaGui_ImplVulkan_CreatePipeline) being used by the backend </td></tr>
    <tr><td class="paramname">commandBuffer</td><td>The vulkan commandbuffer (taken from VulkanRendererAPI.m_CommandBuffer) being used by the backend, see todo list. </td></tr>
    <tr><td class="paramname">remderingBufferData</td><td>The set of buffers relevant to current frame (in flight?) </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width size </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height size</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000085">Todo</a></b></dt><dd>Ponder over the commandBuffer usage (should backend have seperate commandbuffer?) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a09e6fbd79125a5759c82f87aaa7eed33" name="a09e6fbd79125a5759c82f87aaa7eed33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e6fbd79125a5759c82f87aaa7eed33">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_SetupRenderStateFor3DRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_SetupRenderStateFor3DRendering </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_karma_1_1_scene.html">Scene</a> *</td>          <td class="paramname"><span class="paramname"><em>sceneToDraw</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VkCommandBuffer</td>          <td class="paramname"><span class="paramname"><em>commandBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_k_g_draw_data.html">KGDrawData</a> *</td>          <td class="paramname"><span class="paramname"><em>drawData</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A routine to bind index/vertex buffers, setup a external viewport, and bind pipeline. Specifically for 3D rendering in KarmaGUI's window for (experimental) 3D exhibition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawData</td><td>All draw data to render a <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a> frame </td></tr>
    <tr><td class="paramname">pipeline</td><td>The vulkan pipeline (created in KarmaGui_ImplVulkan_CreatePipeline) being used by the backend </td></tr>
    <tr><td class="paramname">commandBuffer</td><td>The vulkan commandbuffer (taken from VulkanRendererAPI.m_CommandBuffer) being used by the backend, see todo list. </td></tr>
    <tr><td class="paramname">remderingBufferData</td><td>The set of buffers relevant to current frame (in flight?) </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width size </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height size</td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000086">Todo</a></b></dt><dd>Ponder over the commandBuffer usage (should backend have seperate commandbuffer?) </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a2fe945584a8c6cc1b93cce469ea71961" name="a2fe945584a8c6cc1b93cce469ea71961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fe945584a8c6cc1b93cce469ea71961">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_SetWindowSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_SetWindowSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *</td>          <td class="paramname"><span class="paramname"><em>viewport</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_k_g_vec2.html">KGVec2</a></td>          <td class="paramname"><span class="paramname"><em>size</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of window rendering relevant resources (swapchain, framebuffers, and all that). Basically implementation of <a class="el" href="struct_karma_gui_platform_i_o.html#aa283022b931f333a1db0a0665a81fed4" title="Resize swap chain, frame buffers etc. (called after Platform_SetWindowSize)">KarmaGuiPlatformIO::Renderer_SetWindowSize</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The current platform window to be resized </td></tr>
    <tr><td class="paramname">size</td><td>The 2D vector containing width and height of the window</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Can't find any use in the current state of Engine. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a3f0a1ac0b54a0b7ce3896636d75a78c4" name="a3f0a1ac0b54a0b7ce3896636d75a78c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0a1ac0b54a0b7ce3896636d75a78c4">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_ShivaFrameRenderBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_ShivaFrameRenderBuffers </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers</a> *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys and clears the following buffers. </p>
<ol type="1">
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html#a02160c859f8974ef45b4ef8ced8e79b9" title="Vulkan buffer to be bound to KarmaGui_Vulkan_Frame_On_Flight::CommandBuffer for vertexbuffer.">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers::VertexBuffer</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html#a13f604c2c2a0c96fc7a7b19d360d2513" title="Device (KarmaGui_ImplVulkan_InitInfo::Device) memory allocated via vkAllocateMemory for containing ve...">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers::VertexBufferMemory</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html#ad9ed87fba606d838f61310cb7c033d99" title="Vulkan buffer to be bound to KarmaGui_Vulkan_Frame_On_Flight::CommandBuffer for indexbuffer.">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers::IndexBuffer</a></li>
<li><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html#a8267bee532893cb0c529ade10a266cf7" title="Device (KarmaGui_ImplVulkan_InitInfo::Device) memory allocated via vkAllocateMemory for containing in...">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers::IndexBufferMemory</a></li>
<li>Zeroing <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html#ac039d512c146b3c770524ea69816343c" title="The size in bytes of the index buffer.">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers::IndexBufferSize</a>, <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html#aa66f0b74e9e6759e6b0d5452bbdcad76" title="The size in bytes of the vertex buffer.">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers::VertexBufferSize</a></li>
</ol>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="af0fcca8d4decb19e46348685131ee6dc" name="af0fcca8d4decb19e46348685131ee6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fcca8d4decb19e46348685131ee6dc">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_ShivaWindowRenderBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_ShivaWindowRenderBuffers </td>
          <td>(</td>
          <td class="paramtype">VkDevice</td>          <td class="paramname"><span class="paramname"><em>device</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window_render_buffers.html">KarmaGui_ImplVulkanH_WindowRenderBuffers</a> *</td>          <td class="paramname"><span class="paramname"><em>buffers</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VkAllocationCallbacks *</td>          <td class="paramname"><span class="paramname"><em>allocator</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroys and clears the frame buffers, <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window_render_buffers.html#a2b0dc6dd76f73e641d9a5616289d31a0" title="Reusable buffers used for rendering, to be instantiated.">KarmaGui_ImplVulkanH_WindowRenderBuffers::FrameRenderBuffers</a>, using KarmaGui_ImplVulkan_ShivaFrameRenderBuffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A logical device handle. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#ac22663acc56381a44ad59eac1e159276" title="A logical device handle. Device is an appropriate instance using which swapchains,...">KarmaGui_ImplVulkan_InitInfo.Device</a> </td></tr>
    <tr><td class="paramname">buffers</td><td>The rendering buffers allocated for a in-flight ImageFrame (<a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame_render_buffers.html" title="Reusable buffers used for rendering 1 current in-flight ImageFrame, for KarmaGui_ImplVulkan_RenderDra...">KarmaGui_ImplVulkanH_ImageFrameRenderBuffers</a>) </td></tr>
    <tr><td class="paramname">allocator</td><td>The controller of host memory allocation as described in the Memory Allocation chapter. See <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan___init_info.html#acb44f9a1a46c09a6244eb2ddcb57f0c4" title="A pointer to a valid VkAllocationCallbacks structure. Structure containing callback function pointers...">KarmaGui_ImplVulkan_InitInfo.Allocator</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a4e8f9c6e2dcc1f47adc41ed6f55370d9" name="a4e8f9c6e2dcc1f47adc41ed6f55370d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8f9c6e2dcc1f47adc41ed6f55370d9">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_Shutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_Shutdown </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called in the KarmaGuiRenderer::GracefulVulkanShutDown(). Basically does the following. </p>
<ol type="1">
<li><a class="el" href="#a1474726a454ef471ef767f903f5551da" title="The following objects are destroyed.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyDeviceObjects</a> // (destroy object in viewport(s))</li>
<li><a class="el" href="#aef31ff42b26af3f3f9b7b348ca304f42" title="Calls KarmaGui::DestroyPlatformWindows, which further calls KarmaGuiInternal::DestroyPlatformWindow o...">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_ShutdownPlatformInterface()</a></li>
<li>Delete <a class="el" href="struct_karma_1_1_karma_gui_backend_renderer_user_data.html" title="A multiply inherited class for supporting both OpenGL and Vulkan API&#39;s.">KarmaGuiBackendRendererUserData</a></li>
</ol>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aef31ff42b26af3f3f9b7b348ca304f42" name="aef31ff42b26af3f3f9b7b348ca304f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef31ff42b26af3f3f9b7b348ca304f42">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_ShutdownPlatformInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_ShutdownPlatformInterface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls KarmaGui::DestroyPlatformWindows, which further calls KarmaGuiInternal::DestroyPlatformWindow on each viewport window (main viewport in current state). Clears the RendererUserData and calls <a class="el" href="#a42881b7018110e014a12ce23d329da65" title="Destroys the KarmaGui window relevant data (KarmaGui_ImplVulkan_ViewportData) and buffers....">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_DestroyWindow</a>. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a00a73f7f1e709e8615bff7dc1e5aa00a" name="a00a73f7f1e709e8615bff7dc1e5aa00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a73f7f1e709e8615bff7dc1e5aa00a">&#9670;&#160;</a></span>KarmaGui_ImplVulkan_SwapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_SwapBuffers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_gui_viewport.html">KarmaGuiViewport</a> *</td>          <td class="paramname"><span class="paramname"><em>viewport</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called in KarmaGui_ImplVulkan_InitPlatformInterface for setting the field <a class="el" href="struct_karma_gui_platform_i_o.html#a4ec5324e8fa2e131a51fd0f38e6d33bc" title="(Optional) Call Present/SwapBuffers. &#39;render_arg&#39; is the value passed to Karma::KarmaGui::RenderPlatf...">KarmaGuiPlatformIO::Renderer_SwapBuffers</a>. Based upon the present conditions, does the following. </p>
<ol type="1">
<li>Calls the routine <a class="el" href="#aee8565ba0b84ee6611092898b9a94d2d" title="KarmaGui_ImplVulkan_CreateOrResizeWindow.">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_CreateOrResizeWindow</a> if vkQueuePresentKHR returns VK_ERROR_OUT_OF_DATE_KHR or VK_SUBOPTIMAL_KHR.</li>
<li>Update the <a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html#a2434955c7533a2fea20d7acd813634e9" title="Current set of swapchain wait semaphores and command buffers we&#39;re using (0 &lt;= SemaphoreIndex &lt; MAX_F...">KarmaGui_ImplVulkanH_Window::SemaphoreIndex</a> for graceful asynchronous (<a href="https://www.geeksforgeeks.org/semaphores-in-process-synchronization/">https://www.geeksforgeeks.org/semaphores-in-process-synchronization/</a>) type of work. A semaphore is used to add order between queue operations. Queue operations refer to the work we submit to a queue, either in a command buffer or from within a function. Examples of queues are the graphics queue and the presentation queue. Semaphores are used both to order work inside the same queue and between different queues.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">viewport</td><td>The viewport to be rendered</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not used in the current state of single viewport only condition of Engine. </dd>
<dd>
Needs reconsideration because of the same decoupling (see <a class="el" href="struct_karma_1_1_karma_gui___vulkan___frame___on___flight.html" title="Data structure for synchronous operations (relevant to rendering in this context).">KarmaGui_Vulkan_Frame_On_Flight</a> notes). Seems like we have taken those considerations and resoved the decoupling issue. </dd>
<dd>
A core design philosophy in Vulkan is that synchronization of execution on the GPU is explicit. The order of operations is up to us to define using various synchronization primitives which tell the driver the order we want things to run in. This means that many Vulkan API calls which start executing work on the GPU are asynchronous, the functions will return before the operation has finished. Retrieved from <a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_Synchronization">https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_Synchronization</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_karma_1_1_karma_gui___vulkan___frame___on___flight.html" title="Data structure for synchronous operations (relevant to rendering in this context).">KarmaGui_Vulkan_Frame_On_Flight</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ac2c93fab4bd1c3b354b46485db32a8d6" name="ac2c93fab4bd1c3b354b46485db32a8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c93fab4bd1c3b354b46485db32a8d6">&#9670;&#160;</a></span>ShareVulkanContextResourcesOfMainWindow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::KarmaGuiVulkanHandler::ShareVulkanContextResourcesOfMainWindow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a> *</td>          <td class="paramname"><span class="paramname"><em>windowData</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>bCreateSyncronicity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The purpose of the routine is two-fold. </p>
<ul>
<li>Share the Vulkan resources, including Swapchain, Renderpass, CommandPool, Framebuffer, and all that, of MainWindow (stored in <a class="el" href="class_karma_1_1_vulkan_context.html" title="Vulkan API has the following concepts.">VulkanContext</a> of <a class="el" href="class_karma_1_1_vulkan_holder.html">VulkanHolder</a>, initialized during <a class="el" href="class_karma_1_1_vulkan_context.html#ae07d2db438aac38447337bed1c940713" title="Initializes VulkanContext by creating appropriate Vulkan and glslang specific instruments and allocat...">VulkanContext::Init()</a> which gets called on Platform(Windows, Mac, and Linux)<a class="el" href="class_karma_1_1_window.html" title="The abstract base class of Karma&#39;s window (for platform specific purposes)">Window</a> during their specific creation implementation, for instance LinuxWindow::Init) to <a class="el" href="class_karma_1_1_karma_gui.html">KarmaGui</a>'s backend, after appropriate clearence.</li>
<li>Ground work for establishing syncronicity, in GPU side functions' execution, by creating semaphores for (<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_Synchronization">https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation#page_Synchronization</a>)<ol type="1">
<li>to signal that image has been acquired from the swapchain and ready for rendering</li>
<li>to signal that rendering has finished and presentation (the last step of drawing a frame is submitting the result back to the swap chain to have it eventually show up on the screen) can happen The set number of semaphores (we are using two types of them) are for number of "frames in flight" which represent the number of frames which can be processed on CPU whilst rendering is done on GPU</li>
</ol>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowData</td><td>The datastructure to hold all the data needed by one rendering Vulkan context. </td></tr>
    <tr><td class="paramname">bCreateSyncronicity</td><td>Should we allocate semaphores and fences. For instance true during <a class="el" href="class_karma_1_1_karma_gui_renderer.html#a5cb4f523b4ab2e3580247d7cac491467" title="Sets the renderer for KarmaGui based on programmer&#39;s choice.">KarmaGuiRenderer::SetUpKarmaGuiRenderer</a> and false during KarmaGuiRenderer::GiveLoopBeginControlToVulkan</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Karma/src/Platform/Vulkan/<a class="el" href="_karma_gui_vulkan_handler_8h_source.html">KarmaGuiVulkanHandler.h</a></li>
<li>Karma/src/Platform/Vulkan/<b>KarmaGuiVulkanHandler.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
