<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KarmaEngine: Karma::VulkanContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KarmaEngine
   </div>
   <div id="projectbrief">Game Engine for practical learning and research purposes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Karma</b></li><li class="navelem"><a class="el" href="class_karma_1_1_vulkan_context.html">VulkanContext</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_karma_1_1_vulkan_context-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Karma::VulkanContext Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Vulkan API has the following concepts.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_vulkan_context_8h_source.html">VulkanContext.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Karma::VulkanContext:</div>
<div class="dyncontent">
<div class="center"><img src="class_karma_1_1_vulkan_context__inherit__graph.png" border="0" usemap="#a_karma_1_1_vulkan_context_inherit__map" alt="Inheritance graph"/></div>
<map name="a_karma_1_1_vulkan_context_inherit__map" id="a_karma_1_1_vulkan_context_inherit__map">
<area shape="rect" title="Vulkan API has the following concepts." alt="" coords="11,79,161,105"/>
<area shape="rect" href="class_karma_1_1_graphics_context.html" title="An abstract class for creating a context for Renderer and provide graphics API." alt="" coords="5,5,167,31"/>
<area shape="poly" title=" " alt="" coords="89,46,89,79,83,79,83,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for Karma::VulkanContext:</div>
<div class="dyncontent">
<div class="center"><img src="class_karma_1_1_vulkan_context__coll__graph.png" border="0" usemap="#a_karma_1_1_vulkan_context_coll__map" alt="Collaboration graph"/></div>
<map name="a_karma_1_1_vulkan_context_coll__map" id="a_karma_1_1_vulkan_context_coll__map">
<area shape="rect" title="Vulkan API has the following concepts." alt="" coords="11,79,161,105"/>
<area shape="rect" href="class_karma_1_1_graphics_context.html" title="An abstract class for creating a context for Renderer and provide graphics API." alt="" coords="5,5,167,31"/>
<area shape="poly" title=" " alt="" coords="89,46,89,79,83,79,83,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a583612ff1cb505434affe692d444168f" id="r_a583612ff1cb505434affe692d444168f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a583612ff1cb505434affe692d444168f">VulkanContext</a> (GLFWwindow *windowHandle)</td></tr>
<tr class="memdesc:a583612ff1cb505434affe692d444168f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A constructor to set the m_vulkanRendererAPI (using static_cast, or compilet time cast). Also checks the validity of windowHandle.  <br /></td></tr>
<tr class="separator:a583612ff1cb505434affe692d444168f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff051cf28280933d857368847979a6bb" id="r_aff051cf28280933d857368847979a6bb"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff051cf28280933d857368847979a6bb">~VulkanContext</a> () override</td></tr>
<tr class="memdesc:aff051cf28280933d857368847979a6bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of vulkan context. Does the following.  <br /></td></tr>
<tr class="separator:aff051cf28280933d857368847979a6bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07d2db438aac38447337bed1c940713" id="r_ae07d2db438aac38447337bed1c940713"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae07d2db438aac38447337bed1c940713">Init</a> () override</td></tr>
<tr class="memdesc:ae07d2db438aac38447337bed1c940713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes <a class="el" href="class_karma_1_1_vulkan_context.html" title="Vulkan API has the following concepts.">VulkanContext</a> by creating appropriate Vulkan and glslang specific instruments and allocating resources accordingly.  <br /></td></tr>
<tr class="separator:ae07d2db438aac38447337bed1c940713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97415930a02a69e31cea2ad06d3a3820" id="r_a97415930a02a69e31cea2ad06d3a3820"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97415930a02a69e31cea2ad06d3a3820">SwapBuffers</a> () override</td></tr>
<tr class="memdesc:a97415930a02a69e31cea2ad06d3a3820"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function swaps the front and back buffers of the specified window. If the swap interval is greater than zero, the GPU driver waits the specified number of screen updates before swapping the buffers.  <br /></td></tr>
<tr class="separator:a97415930a02a69e31cea2ad06d3a3820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bd0d59a1a7c511a0f17aa38887869ee" id="r_a8bd0d59a1a7c511a0f17aa38887869ee"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8bd0d59a1a7c511a0f17aa38887869ee">OnWindowResize</a> (<a class="el" href="class_karma_1_1_window_resize_event.html">WindowResizeEvent</a> &amp;event) override</td></tr>
<tr class="memdesc:a8bd0d59a1a7c511a0f17aa38887869ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls glViewport function which specifies the affine transformation of x and y from normalized device coordinates to window coordinates.  <br /></td></tr>
<tr class="separator:a8bd0d59a1a7c511a0f17aa38887869ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c40b6c0bc689db8130573a39e7bee2" id="r_a56c40b6c0bc689db8130573a39e7bee2"><td class="memItemLeft" align="right" valign="top"><a id="a56c40b6c0bc689db8130573a39e7bee2" name="a56c40b6c0bc689db8130573a39e7bee2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CreateInstance</b> ()</td></tr>
<tr class="separator:a56c40b6c0bc689db8130573a39e7bee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6cf9f32a7d5bfa50d07ddc7164cd42" id="r_afd6cf9f32a7d5bfa50d07ddc7164cd42"><td class="memItemLeft" align="right" valign="top"><a id="afd6cf9f32a7d5bfa50d07ddc7164cd42" name="afd6cf9f32a7d5bfa50d07ddc7164cd42"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintAvailableExtensions</b> ()</td></tr>
<tr class="separator:afd6cf9f32a7d5bfa50d07ddc7164cd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8d03865082465b4b21022f5f3df1d1" id="r_aec8d03865082465b4b21022f5f3df1d1"><td class="memItemLeft" align="right" valign="top"><a id="aec8d03865082465b4b21022f5f3df1d1" name="aec8d03865082465b4b21022f5f3df1d1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PrintAvailablePhysicalDevices</b> (const std::vector&lt; VkPhysicalDevice &gt; &amp;physicalDevices)</td></tr>
<tr class="separator:aec8d03865082465b4b21022f5f3df1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af04874e82035581abdcf222996281824" id="r_af04874e82035581abdcf222996281824"><td class="memItemLeft" align="right" valign="top"><a id="af04874e82035581abdcf222996281824" name="af04874e82035581abdcf222996281824"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckValidationLayerSupport</b> ()</td></tr>
<tr class="separator:af04874e82035581abdcf222996281824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3e4307c50b9160f63c84046b0080e67" id="r_ae3e4307c50b9160f63c84046b0080e67"><td class="memItemLeft" align="right" valign="top"><a id="ae3e4307c50b9160f63c84046b0080e67" name="ae3e4307c50b9160f63c84046b0080e67"></a>
std::vector&lt; const char * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>GetRequiredExtensions</b> (VkInstanceCreateFlags &amp;flagsToBeSet)</td></tr>
<tr class="separator:ae3e4307c50b9160f63c84046b0080e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d45a44df60747bdf821ceb883ec2272" id="r_a8d45a44df60747bdf821ceb883ec2272"><td class="memItemLeft" align="right" valign="top"><a id="a8d45a44df60747bdf821ceb883ec2272" name="a8d45a44df60747bdf821ceb883ec2272"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetupDebugMessenger</b> ()</td></tr>
<tr class="separator:a8d45a44df60747bdf821ceb883ec2272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55ef15fc5eb12737bb8fbad6777eb1b" id="r_ab55ef15fc5eb12737bb8fbad6777eb1b"><td class="memItemLeft" align="right" valign="top"><a id="ab55ef15fc5eb12737bb8fbad6777eb1b" name="ab55ef15fc5eb12737bb8fbad6777eb1b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PopulateDebugMessengerCreateInfo</b> (VkDebugUtilsMessengerCreateInfoEXT &amp;createInfo)</td></tr>
<tr class="separator:ab55ef15fc5eb12737bb8fbad6777eb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7922e7be928903b00e022aa50689a87c" id="r_a7922e7be928903b00e022aa50689a87c"><td class="memItemLeft" align="right" valign="top"><a id="a7922e7be928903b00e022aa50689a87c" name="a7922e7be928903b00e022aa50689a87c"></a>
VkResult&#160;</td><td class="memItemRight" valign="bottom"><b>CreateDebugUtilsMessengerEXT</b> (VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pDebugMessenger)</td></tr>
<tr class="separator:a7922e7be928903b00e022aa50689a87c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a76d97839249db5109d6105c9f497b2" id="r_a2a76d97839249db5109d6105c9f497b2"><td class="memItemLeft" align="right" valign="top"><a id="a2a76d97839249db5109d6105c9f497b2" name="a2a76d97839249db5109d6105c9f497b2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>DestroyDebugUtilsMessengerEXT</b> (VkInstance instance, VkDebugUtilsMessengerEXT debugMessenger, const VkAllocationCallbacks *pAllocator)</td></tr>
<tr class="separator:a2a76d97839249db5109d6105c9f497b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb00492d6e134b605a00ed599b2a6c4" id="r_acbb00492d6e134b605a00ed599b2a6c4"><td class="memItemLeft" align="right" valign="top"><a id="acbb00492d6e134b605a00ed599b2a6c4" name="acbb00492d6e134b605a00ed599b2a6c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CreateSurface</b> ()</td></tr>
<tr class="separator:acbb00492d6e134b605a00ed599b2a6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad165c3848ece8a475fce66ea2023cc" id="r_afad165c3848ece8a475fce66ea2023cc"><td class="memItemLeft" align="right" valign="top"><a id="afad165c3848ece8a475fce66ea2023cc" name="afad165c3848ece8a475fce66ea2023cc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>PickPhysicalDevice</b> ()</td></tr>
<tr class="separator:afad165c3848ece8a475fce66ea2023cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75221e66d5cd1a6b93c3d8be3571500" id="r_aa75221e66d5cd1a6b93c3d8be3571500"><td class="memItemLeft" align="right" valign="top"><a id="aa75221e66d5cd1a6b93c3d8be3571500" name="aa75221e66d5cd1a6b93c3d8be3571500"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsDeviceSuitable</b> (VkPhysicalDevice device)</td></tr>
<tr class="separator:aa75221e66d5cd1a6b93c3d8be3571500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de5ebe667dc946ef303d6e42eb41edc" id="r_a3de5ebe667dc946ef303d6e42eb41edc"><td class="memItemLeft" align="right" valign="top"><a id="a3de5ebe667dc946ef303d6e42eb41edc" name="a3de5ebe667dc946ef303d6e42eb41edc"></a>
<a class="el" href="struct_karma_1_1_queue_family_indices.html">QueueFamilyIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FindQueueFamilies</b> (VkPhysicalDevice device)</td></tr>
<tr class="separator:a3de5ebe667dc946ef303d6e42eb41edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1f0e963dfe33514587e524c6ec973d" id="r_ada1f0e963dfe33514587e524c6ec973d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada1f0e963dfe33514587e524c6ec973d">CreateLogicalDevice</a> ()</td></tr>
<tr class="memdesc:ada1f0e963dfe33514587e524c6ec973d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The so called logical device for interfacing with the physical device. All the machinery (swapchain, graphicspipeline, and all that) are created from logical device.  <br /></td></tr>
<tr class="separator:ada1f0e963dfe33514587e524c6ec973d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d367e332d968a2c5ba25c3759bff2b5" id="r_a2d367e332d968a2c5ba25c3759bff2b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2d367e332d968a2c5ba25c3759bff2b5">CreateSwapChain</a> ()</td></tr>
<tr class="memdesc:a2d367e332d968a2c5ba25c3759bff2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan does not have the concept of a "default framebuffer", hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the swap chain and must be created explicitly in Vulkan. The swap chain is essentially a queue of images that are waiting to be presented to the screen. Our backend will acquire such an image to draw to it, and then return it to the queue.  <br /></td></tr>
<tr class="separator:a2d367e332d968a2c5ba25c3759bff2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19eac2cedd2049cb443f426fadf9e79c" id="r_a19eac2cedd2049cb443f426fadf9e79c"><td class="memItemLeft" align="right" valign="top"><a id="a19eac2cedd2049cb443f426fadf9e79c" name="a19eac2cedd2049cb443f426fadf9e79c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>CheckDeviceExtensionSupport</b> (VkPhysicalDevice device)</td></tr>
<tr class="separator:a19eac2cedd2049cb443f426fadf9e79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b62af69e4d46e385abfb9b998bd0c81" id="r_a0b62af69e4d46e385abfb9b998bd0c81"><td class="memItemLeft" align="right" valign="top"><a id="a0b62af69e4d46e385abfb9b998bd0c81" name="a0b62af69e4d46e385abfb9b998bd0c81"></a>
<a class="el" href="struct_karma_1_1_swap_chain_support_details.html">SwapChainSupportDetails</a>&#160;</td><td class="memItemRight" valign="bottom"><b>QuerySwapChainSupport</b> (VkPhysicalDevice device)</td></tr>
<tr class="separator:a0b62af69e4d46e385abfb9b998bd0c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8989c5787a77aa8363f64f9dc8deae1f" id="r_a8989c5787a77aa8363f64f9dc8deae1f"><td class="memItemLeft" align="right" valign="top"><a id="a8989c5787a77aa8363f64f9dc8deae1f" name="a8989c5787a77aa8363f64f9dc8deae1f"></a>
VkSurfaceFormatKHR&#160;</td><td class="memItemRight" valign="bottom"><b>ChooseSwapSurfaceFormat</b> (const std::vector&lt; VkSurfaceFormatKHR &gt; &amp;availableFormats)</td></tr>
<tr class="separator:a8989c5787a77aa8363f64f9dc8deae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc09c4f580967d940b6c56ee5e3d8985" id="r_adc09c4f580967d940b6c56ee5e3d8985"><td class="memItemLeft" align="right" valign="top"><a id="adc09c4f580967d940b6c56ee5e3d8985" name="adc09c4f580967d940b6c56ee5e3d8985"></a>
VkPresentModeKHR&#160;</td><td class="memItemRight" valign="bottom"><b>ChooseSwapPresentMode</b> (const std::vector&lt; VkPresentModeKHR &gt; &amp;availablePresentModes)</td></tr>
<tr class="separator:adc09c4f580967d940b6c56ee5e3d8985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7923ffd44b5cd7767c450565d52f75" id="r_a7b7923ffd44b5cd7767c450565d52f75"><td class="memItemLeft" align="right" valign="top"><a id="a7b7923ffd44b5cd7767c450565d52f75" name="a7b7923ffd44b5cd7767c450565d52f75"></a>
VkExtent2D&#160;</td><td class="memItemRight" valign="bottom"><b>ChooseSwapExtent</b> (const VkSurfaceCapabilitiesKHR &amp;capabilities)</td></tr>
<tr class="separator:a7b7923ffd44b5cd7767c450565d52f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf0e5158292b8ee2294b9d61544d832" id="r_abbf0e5158292b8ee2294b9d61544d832"><td class="memItemLeft" align="right" valign="top"><a id="abbf0e5158292b8ee2294b9d61544d832" name="abbf0e5158292b8ee2294b9d61544d832"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>FindMemoryType</b> (uint32_t typeFilter, VkMemoryPropertyFlags properties)</td></tr>
<tr class="separator:abbf0e5158292b8ee2294b9d61544d832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b84cc1c4edf52881d495e34104f9e7f" id="r_a3b84cc1c4edf52881d495e34104f9e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3b84cc1c4edf52881d495e34104f9e7f">CreateImageViews</a> ()</td></tr>
<tr class="memdesc:a3b84cc1c4edf52881d495e34104f9e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An image view is quite literally a view into an image. It describes how to access the image and which part of the image to access, for example if it should be treated as a 2D texture depth texture without any mipmapping levels.  <br /></td></tr>
<tr class="separator:a3b84cc1c4edf52881d495e34104f9e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab653bd5254de11636e5f52bd59aa57c9" id="r_ab653bd5254de11636e5f52bd59aa57c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab653bd5254de11636e5f52bd59aa57c9">CreateRenderPass</a> ()</td></tr>
<tr class="memdesc:ab653bd5254de11636e5f52bd59aa57c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A VkRenderPass is a Vulkan object that encapsulates the state needed to setup the “target” for rendering, and the state of the images we will be rendering to.  <br /></td></tr>
<tr class="separator:ab653bd5254de11636e5f52bd59aa57c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8af4361e52a385ff692a1a0696ddb8" id="r_aba8af4361e52a385ff692a1a0696ddb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba8af4361e52a385ff692a1a0696ddb8">CreateFrameBuffers</a> ()</td></tr>
<tr class="memdesc:aba8af4361e52a385ff692a1a0696ddb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A framebuffer represents a collection of specific memory attachments that a render pass instance uses.  <br /></td></tr>
<tr class="separator:aba8af4361e52a385ff692a1a0696ddb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0919004c0e5350bf6af9cae89b7b0af" id="r_ae0919004c0e5350bf6af9cae89b7b0af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae0919004c0e5350bf6af9cae89b7b0af">CreateCommandPool</a> ()</td></tr>
<tr class="memdesc:ae0919004c0e5350bf6af9cae89b7b0af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation.  <br /></td></tr>
<tr class="separator:ae0919004c0e5350bf6af9cae89b7b0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68267886cdd5f06b0944ffb2d4aff319" id="r_a68267886cdd5f06b0944ffb2d4aff319"><td class="memItemLeft" align="right" valign="top"><a id="a68267886cdd5f06b0944ffb2d4aff319" name="a68267886cdd5f06b0944ffb2d4aff319"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CreateDepthResources</b> ()</td></tr>
<tr class="separator:a68267886cdd5f06b0944ffb2d4aff319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a9b8ee8cfa0ff2e56fdd2600e17e0c" id="r_aa3a9b8ee8cfa0ff2e56fdd2600e17e0c"><td class="memItemLeft" align="right" valign="top"><a id="aa3a9b8ee8cfa0ff2e56fdd2600e17e0c" name="aa3a9b8ee8cfa0ff2e56fdd2600e17e0c"></a>
VkFormat&#160;</td><td class="memItemRight" valign="bottom"><b>FindSupportedFormat</b> (const std::vector&lt; VkFormat &gt; &amp;candidates, VkImageTiling tiling, VkFormatFeatureFlags features)</td></tr>
<tr class="separator:aa3a9b8ee8cfa0ff2e56fdd2600e17e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3db954f21a39acae61674dbfa207d11" id="r_ac3db954f21a39acae61674dbfa207d11"><td class="memItemLeft" align="right" valign="top"><a id="ac3db954f21a39acae61674dbfa207d11" name="ac3db954f21a39acae61674dbfa207d11"></a>
VkFormat&#160;</td><td class="memItemRight" valign="bottom"><b>FindDepthFormat</b> ()</td></tr>
<tr class="separator:ac3db954f21a39acae61674dbfa207d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d733eba5be4197f7d1f98a66822863" id="r_a25d733eba5be4197f7d1f98a66822863"><td class="memItemLeft" align="right" valign="top"><a id="a25d733eba5be4197f7d1f98a66822863" name="a25d733eba5be4197f7d1f98a66822863"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>HasStencilComponent</b> (VkFormat format)</td></tr>
<tr class="separator:a25d733eba5be4197f7d1f98a66822863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640eafd4350e7dff07615bae04b2910a" id="r_a640eafd4350e7dff07615bae04b2910a"><td class="memItemLeft" align="right" valign="top"><a id="a640eafd4350e7dff07615bae04b2910a" name="a640eafd4350e7dff07615bae04b2910a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TransitionImageLayout</b> (VkImage image, VkFormat format, VkImageLayout oldLayout, VkImageLayout newLayout)</td></tr>
<tr class="separator:a640eafd4350e7dff07615bae04b2910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39020fabab52359ce1286f0e44c9a86d" id="r_a39020fabab52359ce1286f0e44c9a86d"><td class="memItemLeft" align="right" valign="top"><a id="a39020fabab52359ce1286f0e44c9a86d" name="a39020fabab52359ce1286f0e44c9a86d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CopyBufferToImage</b> (VkBuffer buffer, VkImage image, uint32_t width, uint32_t height)</td></tr>
<tr class="separator:a39020fabab52359ce1286f0e44c9a86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b008c73d61c5bb7949ade1729a36b53" id="r_a9b008c73d61c5bb7949ade1729a36b53"><td class="memItemLeft" align="right" valign="top"><a id="a9b008c73d61c5bb7949ade1729a36b53" name="a9b008c73d61c5bb7949ade1729a36b53"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RecreateSwapChain</b> ()</td></tr>
<tr class="separator:a9b008c73d61c5bb7949ade1729a36b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200a5a48a832dc021af7a0478c21d8df" id="r_a200a5a48a832dc021af7a0478c21d8df"><td class="memItemLeft" align="right" valign="top"><a id="a200a5a48a832dc021af7a0478c21d8df" name="a200a5a48a832dc021af7a0478c21d8df"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>CleanupSwapChain</b> ()</td></tr>
<tr class="separator:a200a5a48a832dc021af7a0478c21d8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a874bcd49d4121b95a8f95c5507c626d5" id="r_a874bcd49d4121b95a8f95c5507c626d5"><td class="memItemLeft" align="right" valign="top"><a id="a874bcd49d4121b95a8f95c5507c626d5" name="a874bcd49d4121b95a8f95c5507c626d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetVSync</b> (bool bEnable)</td></tr>
<tr class="separator:a874bcd49d4121b95a8f95c5507c626d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfdfa7c10ef2bf92d4f5228b722dd080" id="r_abfdfa7c10ef2bf92d4f5228b722dd080"><td class="memItemLeft" align="right" valign="top"><a id="abfdfa7c10ef2bf92d4f5228b722dd080" name="abfdfa7c10ef2bf92d4f5228b722dd080"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>Initializeglslang</b> ()</td></tr>
<tr class="separator:abfdfa7c10ef2bf92d4f5228b722dd080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f8a80f3f98dee0029f19aa917440461" id="r_a6f8a80f3f98dee0029f19aa917440461"><td class="memItemLeft" align="right" valign="top"><a id="a6f8a80f3f98dee0029f19aa917440461" name="a6f8a80f3f98dee0029f19aa917440461"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RegisterUBO</b> (const std::shared_ptr&lt; <a class="el" href="struct_karma_1_1_vulkan_uniform_buffer.html">VulkanUniformBuffer</a> &gt; &amp;ubo)</td></tr>
<tr class="separator:a6f8a80f3f98dee0029f19aa917440461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620cbb199308a721c243793e29e19fac" id="r_a620cbb199308a721c243793e29e19fac"><td class="memItemLeft" align="right" valign="top"><a id="a620cbb199308a721c243793e29e19fac" name="a620cbb199308a721c243793e29e19fac"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ClearUBO</b> ()</td></tr>
<tr class="separator:a620cbb199308a721c243793e29e19fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15923c620c5fb6c8cae59a94d57cce99" id="r_a15923c620c5fb6c8cae59a94d57cce99"><td class="memItemLeft" align="right" valign="top"><a id="a15923c620c5fb6c8cae59a94d57cce99" name="a15923c620c5fb6c8cae59a94d57cce99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>RecreateUBO</b> ()</td></tr>
<tr class="separator:a15923c620c5fb6c8cae59a94d57cce99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6516fa8d4ba38e2b5fdfc4382cf04bf" id="r_ad6516fa8d4ba38e2b5fdfc4382cf04bf"><td class="memItemLeft" align="right" valign="top"><a id="ad6516fa8d4ba38e2b5fdfc4382cf04bf" name="ad6516fa8d4ba38e2b5fdfc4382cf04bf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>UploadUBO</b> (size_t frameIndex)</td></tr>
<tr class="separator:ad6516fa8d4ba38e2b5fdfc4382cf04bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeacebbf81c74bc923ae7dbf3d6b21038" id="r_aeacebbf81c74bc923ae7dbf3d6b21038"><td class="memItemLeft" align="right" valign="top"><a id="aeacebbf81c74bc923ae7dbf3d6b21038" name="aeacebbf81c74bc923ae7dbf3d6b21038"></a>
VkDevice&#160;</td><td class="memItemRight" valign="bottom"><b>GetLogicalDevice</b> () const</td></tr>
<tr class="separator:aeacebbf81c74bc923ae7dbf3d6b21038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5240fe93fefcbb693a536dd210d3e0" id="r_aee5240fe93fefcbb693a536dd210d3e0"><td class="memItemLeft" align="right" valign="top"><a id="aee5240fe93fefcbb693a536dd210d3e0" name="aee5240fe93fefcbb693a536dd210d3e0"></a>
VkPhysicalDevice&#160;</td><td class="memItemRight" valign="bottom"><b>GetPhysicalDevice</b> () const</td></tr>
<tr class="separator:aee5240fe93fefcbb693a536dd210d3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8932bee8017b55ff44afd0627f46cb" id="r_aaf8932bee8017b55ff44afd0627f46cb"><td class="memItemLeft" align="right" valign="top"><a id="aaf8932bee8017b55ff44afd0627f46cb" name="aaf8932bee8017b55ff44afd0627f46cb"></a>
VkExtent2D&#160;</td><td class="memItemRight" valign="bottom"><b>GetSwapChainExtent</b> () const</td></tr>
<tr class="separator:aaf8932bee8017b55ff44afd0627f46cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ef0452b26e67e171dcafb8a335c093" id="r_a60ef0452b26e67e171dcafb8a335c093"><td class="memItemLeft" align="right" valign="top"><a id="a60ef0452b26e67e171dcafb8a335c093" name="a60ef0452b26e67e171dcafb8a335c093"></a>
VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><b>GetRenderPass</b> () const</td></tr>
<tr class="separator:a60ef0452b26e67e171dcafb8a335c093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f3beb38b03d094390fd0487467941d5" id="r_a8f3beb38b03d094390fd0487467941d5"><td class="memItemLeft" align="right" valign="top"><a id="a8f3beb38b03d094390fd0487467941d5" name="a8f3beb38b03d094390fd0487467941d5"></a>
const std::vector&lt; VkFramebuffer &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSwapChainFrameBuffer</b> () const</td></tr>
<tr class="separator:a8f3beb38b03d094390fd0487467941d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06cb37366e73cba973aa9b5e0ea7c34c" id="r_a06cb37366e73cba973aa9b5e0ea7c34c"><td class="memItemLeft" align="right" valign="top"><a id="a06cb37366e73cba973aa9b5e0ea7c34c" name="a06cb37366e73cba973aa9b5e0ea7c34c"></a>
VkSwapchainKHR&#160;</td><td class="memItemRight" valign="bottom"><b>GetSwapChain</b> () const</td></tr>
<tr class="separator:a06cb37366e73cba973aa9b5e0ea7c34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bba1556479ee0ab928b9d96b0089976" id="r_a8bba1556479ee0ab928b9d96b0089976"><td class="memItemLeft" align="right" valign="top"><a id="a8bba1556479ee0ab928b9d96b0089976" name="a8bba1556479ee0ab928b9d96b0089976"></a>
const std::vector&lt; VkImage &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSwapChainImages</b> () const</td></tr>
<tr class="separator:a8bba1556479ee0ab928b9d96b0089976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25453d08232e31656949a00d0761b8ae" id="r_a25453d08232e31656949a00d0761b8ae"><td class="memItemLeft" align="right" valign="top"><a id="a25453d08232e31656949a00d0761b8ae" name="a25453d08232e31656949a00d0761b8ae"></a>
VkFormat&#160;</td><td class="memItemRight" valign="bottom"><b>GetSwapChainImageFormat</b> () const</td></tr>
<tr class="separator:a25453d08232e31656949a00d0761b8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62be4cca2c4461f18ee224016496f97e" id="r_a62be4cca2c4461f18ee224016496f97e"><td class="memItemLeft" align="right" valign="top"><a id="a62be4cca2c4461f18ee224016496f97e" name="a62be4cca2c4461f18ee224016496f97e"></a>
const std::vector&lt; VkImageView &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSwapChainImageViews</b> () const</td></tr>
<tr class="separator:a62be4cca2c4461f18ee224016496f97e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2071a88ec2bfa12adbd86ea9dd14f2" id="r_a7c2071a88ec2bfa12adbd86ea9dd14f2"><td class="memItemLeft" align="right" valign="top"><a id="a7c2071a88ec2bfa12adbd86ea9dd14f2" name="a7c2071a88ec2bfa12adbd86ea9dd14f2"></a>
VkSurfaceFormatKHR&#160;</td><td class="memItemRight" valign="bottom"><b>GetSurfaceFormat</b> () const</td></tr>
<tr class="separator:a7c2071a88ec2bfa12adbd86ea9dd14f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f53744428ac41a4817a96c5cdf2fbbf" id="r_a7f53744428ac41a4817a96c5cdf2fbbf"><td class="memItemLeft" align="right" valign="top"><a id="a7f53744428ac41a4817a96c5cdf2fbbf" name="a7f53744428ac41a4817a96c5cdf2fbbf"></a>
VkQueue&#160;</td><td class="memItemRight" valign="bottom"><b>GetGraphicsQueue</b> () const</td></tr>
<tr class="separator:a7f53744428ac41a4817a96c5cdf2fbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cfd1e23dbb23f7fa8362e45bcc805e" id="r_a33cfd1e23dbb23f7fa8362e45bcc805e"><td class="memItemLeft" align="right" valign="top"><a id="a33cfd1e23dbb23f7fa8362e45bcc805e" name="a33cfd1e23dbb23f7fa8362e45bcc805e"></a>
VkQueue&#160;</td><td class="memItemRight" valign="bottom"><b>GetPresentQueue</b> () const</td></tr>
<tr class="separator:a33cfd1e23dbb23f7fa8362e45bcc805e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4e4c35ec219ac85abf5170b7707818" id="r_a4d4e4c35ec219ac85abf5170b7707818"><td class="memItemLeft" align="right" valign="top"><a id="a4d4e4c35ec219ac85abf5170b7707818" name="a4d4e4c35ec219ac85abf5170b7707818"></a>
VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><b>GetCommandPool</b> () const</td></tr>
<tr class="separator:a4d4e4c35ec219ac85abf5170b7707818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa922b3622d90f76d7c7fd7ed45d7b5e5" id="r_aa922b3622d90f76d7c7fd7ed45d7b5e5"><td class="memItemLeft" align="right" valign="top"><a id="aa922b3622d90f76d7c7fd7ed45d7b5e5" name="aa922b3622d90f76d7c7fd7ed45d7b5e5"></a>
const VkPhysicalDeviceFeatures &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>GetSupportedDeviceFeatures</b> () const</td></tr>
<tr class="separator:aa922b3622d90f76d7c7fd7ed45d7b5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078f2de178dbdbf6eed43143163d2a73" id="r_a078f2de178dbdbf6eed43143163d2a73"><td class="memItemLeft" align="right" valign="top"><a id="a078f2de178dbdbf6eed43143163d2a73" name="a078f2de178dbdbf6eed43143163d2a73"></a>
VkInstance&#160;</td><td class="memItemRight" valign="bottom"><b>GetInstance</b> () const</td></tr>
<tr class="separator:a078f2de178dbdbf6eed43143163d2a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3509eeff9c1b0644e52bf1ab482f471" id="r_ae3509eeff9c1b0644e52bf1ab482f471"><td class="memItemLeft" align="right" valign="top"><a id="ae3509eeff9c1b0644e52bf1ab482f471" name="ae3509eeff9c1b0644e52bf1ab482f471"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetImageCount</b> () const</td></tr>
<tr class="separator:ae3509eeff9c1b0644e52bf1ab482f471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2ff2f8bca177d8815f84c0a6b82482" id="r_a6b2ff2f8bca177d8815f84c0a6b82482"><td class="memItemLeft" align="right" valign="top"><a id="a6b2ff2f8bca177d8815f84c0a6b82482" name="a6b2ff2f8bca177d8815f84c0a6b82482"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>GetMinImageCount</b> () const</td></tr>
<tr class="separator:a6b2ff2f8bca177d8815f84c0a6b82482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa066dcd7eabaf63407b72c32f41b4d8" id="r_afa066dcd7eabaf63407b72c32f41b4d8"><td class="memItemLeft" align="right" valign="top"><a id="afa066dcd7eabaf63407b72c32f41b4d8" name="afa066dcd7eabaf63407b72c32f41b4d8"></a>
VkSurfaceKHR&#160;</td><td class="memItemRight" valign="bottom"><b>GetSurface</b> () const</td></tr>
<tr class="separator:afa066dcd7eabaf63407b72c32f41b4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b9fde525e9911c28a380f800f3a413" id="r_a79b9fde525e9911c28a380f800f3a413"><td class="memItemLeft" align="right" valign="top"><a id="a79b9fde525e9911c28a380f800f3a413" name="a79b9fde525e9911c28a380f800f3a413"></a>
VkPresentModeKHR&#160;</td><td class="memItemRight" valign="bottom"><b>GetPresentMode</b> () const</td></tr>
<tr class="separator:a79b9fde525e9911c28a380f800f3a413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_karma_1_1_graphics_context"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_karma_1_1_graphics_context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_karma_1_1_graphics_context.html">Karma::GraphicsContext</a></td></tr>
<tr class="memitem:a13422669efac1397907da22a6c36aed3 inherit pub_methods_class_karma_1_1_graphics_context" id="r_a13422669efac1397907da22a6c36aed3"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_karma_1_1_graphics_context.html#a13422669efac1397907da22a6c36aed3">~GraphicsContext</a> ()</td></tr>
<tr class="memdesc:a13422669efac1397907da22a6c36aed3 inherit pub_methods_class_karma_1_1_graphics_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">A destructor.  <br /></td></tr>
<tr class="separator:a13422669efac1397907da22a6c36aed3 inherit pub_methods_class_karma_1_1_graphics_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a50f1b2402d58261872ce47866ea33af9" id="r_a50f1b2402d58261872ce47866ea33af9"><td class="memItemLeft" align="right" valign="top"><a id="a50f1b2402d58261872ce47866ea33af9" name="a50f1b2402d58261872ce47866ea33af9"></a>
static VKAPI_ATTR VkBool32 VKAPI_CALL&#160;</td><td class="memItemRight" valign="bottom"><b>DebugCallback</b> (VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageType, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData, void *pUserData)</td></tr>
<tr class="separator:a50f1b2402d58261872ce47866ea33af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Vulkan API has the following concepts. </p>
<ol type="1">
<li>Physical Device (<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families">https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Physical_devices_and_queue_families</a>): The software counterpart (VkPhysicalDevice) of a graphics card (GPU). Logical device is created from physical device.</li>
<li>Device (<a href="https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues">https://vulkan-tutorial.com/Drawing_a_triangle/Setup/Logical_device_and_queues</a>): The so called logical device for interfacing with the physical device. All the machinery (swapchain, graphicspipeline, and all that) are created from logical device.</li>
</ol>
<p>Host : is CPU the host? </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a583612ff1cb505434affe692d444168f" name="a583612ff1cb505434affe692d444168f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583612ff1cb505434affe692d444168f">&#9670;&#160;</a></span>VulkanContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Karma::VulkanContext::VulkanContext </td>
          <td>(</td>
          <td class="paramtype">GLFWwindow *</td>          <td class="paramname"><span class="paramname"><em>windowHandle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A constructor to set the m_vulkanRendererAPI (using static_cast, or compilet time cast). Also checks the validity of windowHandle. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">windowHandle</td><td>The glfw window handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aff051cf28280933d857368847979a6bb" name="aff051cf28280933d857368847979a6bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff051cf28280933d857368847979a6bb">&#9670;&#160;</a></span>~VulkanContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Karma::VulkanContext::~VulkanContext </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor of vulkan context. Does the following. </p>
<ol type="1">
<li>Free the commandbuffers (<a class="el" href="class_karma_1_1_vulkan_renderer_a_p_i.html#ad850654cd636fdd986e8478142f7203f" title="Allocates resources for command buffers. Command buffers are objects used to record commands which ca...">VulkanRendererAPI::AllocateCommandBuffers()</a>) and removes synchronicity</li>
<li>Destroy the framebuffers (<a class="el" href="#aba8af4361e52a385ff692a1a0696ddb8" title="A framebuffer represents a collection of specific memory attachments that a render pass instance uses...">CreateFrameBuffers()</a>)</li>
<li>Destroy depth imageview (CreateDepthResources())</li>
<li>Destroy image (CreateDepthResources())</li>
<li>Free up depthimagememory (CreateDepthResources())</li>
<li>Destroy command pool (<a class="el" href="#ae0919004c0e5350bf6af9cae89b7b0af" title="Command pools are opaque objects that command buffer memory is allocated from, and which allow the im...">CreateCommandPool()</a>)</li>
<li>Destroy render pass (<a class="el" href="#ab653bd5254de11636e5f52bd59aa57c9" title="A VkRenderPass is a Vulkan object that encapsulates the state needed to setup the “target” for render...">CreateRenderPass()</a>)</li>
<li>Destroy swapchain imageview (<a class="el" href="#a3b84cc1c4edf52881d495e34104f9e7f" title="An image view is quite literally a view into an image. It describes how to access the image and which...">CreateImageViews()</a>)</li>
<li>Destroy swapchain (<a class="el" href="#a2d367e332d968a2c5ba25c3759bff2b5" title="Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that...">CreateSwapChain()</a>)</li>
<li>Destroy the vulkan m_device (<a class="el" href="#ada1f0e963dfe33514587e524c6ec973d" title="The so called logical device for interfacing with the physical device. All the machinery (swapchain,...">CreateLogicalDevice()</a>)</li>
<li>Destroy validation layers for debug messages (SetupDebugMessenger())</li>
<li>Destroy surface (CreateSurface())</li>
<li>Destroy instance (CreateInstance())</li>
<li>Destroy glslang memory resources for cleanup</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#ae07d2db438aac38447337bed1c940713" title="Initializes VulkanContext by creating appropriate Vulkan and glslang specific instruments and allocat...">Init()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae0919004c0e5350bf6af9cae89b7b0af" name="ae0919004c0e5350bf6af9cae89b7b0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0919004c0e5350bf6af9cae89b7b0af">&#9670;&#160;</a></span>CreateCommandPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::CreateCommandPool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Command pools are opaque objects that command buffer memory is allocated from, and which allow the implementation to amortize the cost of resource creation. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aba8af4361e52a385ff692a1a0696ddb8" name="aba8af4361e52a385ff692a1a0696ddb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8af4361e52a385ff692a1a0696ddb8">&#9670;&#160;</a></span>CreateFrameBuffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::CreateFrameBuffers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A framebuffer represents a collection of specific memory attachments that a render pass instance uses. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html#ae6ab5c377d34dfdd1667da4b95c5f28e" title="A handle to framebuffer which represents a collection of specific memory attachments that a render pa...">KarmaGui_ImplVulkanH_ImageFrame::Framebuffer</a> </dd></dl>

</div>
</div>
<a id="a3b84cc1c4edf52881d495e34104f9e7f" name="a3b84cc1c4edf52881d495e34104f9e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b84cc1c4edf52881d495e34104f9e7f">&#9670;&#160;</a></span>CreateImageViews()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::CreateImageViews </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An image view is quite literally a view into an image. It describes how to access the image and which part of the image to access, for example if it should be treated as a 2D texture depth texture without any mipmapping levels. </p>
<dl class="section note"><dt>Note</dt><dd>Here we are creating depth images ? </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ada1f0e963dfe33514587e524c6ec973d" name="ada1f0e963dfe33514587e524c6ec973d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada1f0e963dfe33514587e524c6ec973d">&#9670;&#160;</a></span>CreateLogicalDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::CreateLogicalDevice </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The so called logical device for interfacing with the physical device. All the machinery (swapchain, graphicspipeline, and all that) are created from logical device. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ab653bd5254de11636e5f52bd59aa57c9" name="ab653bd5254de11636e5f52bd59aa57c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab653bd5254de11636e5f52bd59aa57c9">&#9670;&#160;</a></span>CreateRenderPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::CreateRenderPass </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A VkRenderPass is a Vulkan object that encapsulates the state needed to setup the “target” for rendering, and the state of the images we will be rendering to. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a2d367e332d968a2c5ba25c3759bff2b5" name="a2d367e332d968a2c5ba25c3759bff2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d367e332d968a2c5ba25c3759bff2b5">&#9670;&#160;</a></span>CreateSwapChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::CreateSwapChain </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vulkan does not have the concept of a "default framebuffer", hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the swap chain and must be created explicitly in Vulkan. The swap chain is essentially a queue of images that are waiting to be presented to the screen. Our backend will acquire such an image to draw to it, and then return it to the queue. </p>
<p>Karma 1.0.0 </p>

</div>
</div>
<a id="ae07d2db438aac38447337bed1c940713" name="ae07d2db438aac38447337bed1c940713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07d2db438aac38447337bed1c940713">&#9670;&#160;</a></span>Init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::Init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initializes <a class="el" href="class_karma_1_1_vulkan_context.html" title="Vulkan API has the following concepts.">VulkanContext</a> by creating appropriate Vulkan and glslang specific instruments and allocating resources accordingly. </p>
<ol type="1">
<li>Create Instance;</li>
<li>Setup Debug Messenger</li>
<li>Create Surface</li>
<li>Pick PhysicalDevice</li>
<li>Create Logical Device</li>
<li>Create Swap Chain</li>
<li>Create ImageViews</li>
<li>Create RenderPass</li>
<li>Create CommandPool</li>
<li>Create DepthResources</li>
<li>Create FrameBuffers</li>
<li>VulkanHolder::SetVulkanContext(this) (VulkanHolder::m_VulkanContext)</li>
<li>m_vulkanRendererAPI-&gt;CreateSynchronicity()</li>
<li>Initialize glslang()</li>
</ol>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#aff051cf28280933d857368847979a6bb" title="Destructor of vulkan context. Does the following.">~VulkanContext()</a> </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

<p>Implements <a class="el" href="class_karma_1_1_graphics_context.html#ac7d8ef2ff9187b9d6e42b90f82d8edda">Karma::GraphicsContext</a>.</p>

</div>
</div>
<a id="a8bd0d59a1a7c511a0f17aa38887869ee" name="a8bd0d59a1a7c511a0f17aa38887869ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bd0d59a1a7c511a0f17aa38887869ee">&#9670;&#160;</a></span>OnWindowResize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Karma::VulkanContext::OnWindowResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_karma_1_1_window_resize_event.html">WindowResizeEvent</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>event</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls glViewport function which specifies the affine transformation of x and y from normalized device coordinates to window coordinates. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000066">Todo</a></b></dt><dd>Seems OpenGL specific. Either think about usage in Vulkan or re design </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

<p>Implements <a class="el" href="class_karma_1_1_graphics_context.html#a640d5490f3704ff4f928c5e749e99fbd">Karma::GraphicsContext</a>.</p>

</div>
</div>
<a id="a97415930a02a69e31cea2ad06d3a3820" name="a97415930a02a69e31cea2ad06d3a3820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97415930a02a69e31cea2ad06d3a3820">&#9670;&#160;</a></span>SwapBuffers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Karma::VulkanContext::SwapBuffers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel override">override</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function swaps the front and back buffers of the specified window. If the swap interval is greater than zero, the GPU driver waits the specified number of screen updates before swapping the buffers. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000065">Todo</a></b></dt><dd>This seems to be an OpenGL specific call. Need to design api accordingly </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

<p>Implements <a class="el" href="class_karma_1_1_graphics_context.html#a482b398d69ae42ffb618b470b25daa21">Karma::GraphicsContext</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Karma/src/Platform/Vulkan/<a class="el" href="_vulkan_context_8h_source.html">VulkanContext.h</a></li>
<li>Karma/src/Platform/Vulkan/<b>VulkanContext.cpp</b></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
