#pragma once

#include "krpch.h"

namespace Karma
{
	class UObject;
	class AActor;
	class UClass;
	class UPackage;
	//enum EObjectFlags;
	//enum class EInternalObjectFlags;

	#define	INVALID_OBJECT	(UObject*)-1

	// 32-bit signed integer <- find or write appropriate class for such type
	typedef signed int	 		int32;

	enum { INDEX_NONE = -1 };

	// Got from EnumClassFlags.h
	template<typename Enum>
	constexpr bool EnumHasAnyFlags(Enum Flags, Enum Contains)
	{
		return(((__underlying_type(Enum))Flags) & (__underlying_type(Enum))Contains) != 0;
	}

	/**
	 * Flags describing a class.
	 *
	 * This MUST be kept in sync with EClassFlags defined in
	 * Engine\Source\Programs\Shared\EpicGames.Core\UnrealEngineTypes.cs
	 */
	enum EClassFlags
	{
		/** No Flags */
		CLASS_None = 0x00000000u,
		/** Class is abstract and can't be instantiated directly. */
		CLASS_Abstract = 0x00000001u,
		/** Save object configuration only to Default INIs, never to local INIs. Must be combined with CLASS_Config */
		CLASS_DefaultConfig = 0x00000002u,
		/** Load object configuration at construction time. */
		CLASS_Config = 0x00000004u,
		/** This object type can't be saved; null it out at save time. */
		CLASS_Transient = 0x00000008u,
		/** This object type may not be available in certain context. (i.e. game runtime or in certain configuration). Optional class data is saved separately to other object types. (i.e. might use sidecar files) */
		CLASS_Optional = 0x00000010u,
		/** */
		CLASS_MatchedSerializers = 0x00000020u,
		/** Indicates that the config settings for this class will be saved to Project/User*.ini (similar to CLASS_GlobalUserConfig) */
		CLASS_ProjectUserConfig = 0x00000040u,
		/** Class is a native class - native interfaces will have CLASS_Native set, but not RF_MarkAsNative */
		CLASS_Native = 0x00000080u,
		/** Don't export to C++ header. */
		//CLASS_NoExport UE_DEPRECATED(5.1, "CLASS_NoExport should no longer be used. It is no longer being set by engine code.") = 0x00000100u,
		/** Do not allow users to create in the editor. */
		CLASS_NotPlaceable = 0x00000200u,
		/** Handle object configuration on a per-object basis, rather than per-class. */
		CLASS_PerObjectConfig = 0x00000400u,

		/** Whether SetUpRuntimeReplicationData still needs to be called for this class */
		CLASS_ReplicationDataIsSetUp = 0x00000800u,

		/** Class can be constructed from editinline New button. */
		CLASS_EditInlineNew = 0x00001000u,
		/** Display properties in the editor without using categories. */
		CLASS_CollapseCategories = 0x00002000u,
		/** Class is an interface **/
		CLASS_Interface = 0x00004000u,
		/**  Do not export a constructor for this class, assuming it is in the cpptext **/
		//CLASS_CustomConstructor UE_DEPRECATED(5.1, "CLASS_CustomConstructor should no longer be used. It is no longer being set by engine code.") = 0x00008000u,
		/** all properties and functions in this class are const and should be exported as const */
		CLASS_Const = 0x00010000u,

		/** Class flag indicating objects of this class need deferred dependency loading */
		CLASS_NeedsDeferredDependencyLoading = 0x00020000u,

		/** Indicates that the class was created from blueprint source material */
		CLASS_CompiledFromBlueprint = 0x00040000u,

		/** Indicates that only the bare minimum bits of this class should be DLL exported/imported */
		CLASS_MinimalAPI = 0x00080000u,

		/** Indicates this class must be DLL exported/imported (along with all of it's members) */
		CLASS_RequiredAPI = 0x00100000u,

		/** Indicates that references to this class default to instanced. Used to be subclasses of UComponent, but now can be any UObject */
		CLASS_DefaultToInstanced = 0x00200000u,

		/** Indicates that the parent token stream has been merged with ours. */
		CLASS_TokenStreamAssembled = 0x00400000u,
		/** Class has component properties. */
		CLASS_HasInstancedReference = 0x00800000u,
		/** Don't show this class in the editor class browser or edit inline new menus. */
		CLASS_Hidden = 0x01000000u,
		/** Don't save objects of this class when serializing */
		CLASS_Deprecated = 0x02000000u,
		/** Class not shown in editor drop down for class selection */
		CLASS_HideDropDown = 0x04000000u,
		/** Class settings are saved to <AppData>/..../Blah.ini (as opposed to CLASS_DefaultConfig) */
		CLASS_GlobalUserConfig = 0x08000000u,
		/** Class was declared directly in C++ and has no boilerplate generated by UnrealHeaderTool */
		CLASS_Intrinsic = 0x10000000u,
		/** Class has already been constructed (maybe in a previous DLL version before hot-reload). */
		CLASS_Constructed = 0x20000000u,
		/** Indicates that object configuration will not check against ini base/defaults when serialized */
		CLASS_ConfigDoNotCheckDefaults = 0x40000000u,
		/** Class has been consigned to oblivion as part of a blueprint recompile, and a newer version currently exists. */
		CLASS_NewerVersionExists = 0x80000000u,
	};

	/**
	 * Package flags, passed into UPackage::SetPackageFlags and related functions
	 *
	 * This MUST be kept in sync with EPackageFlags defined in
	 * Engine\Source\Programs\Shared\EpicGames.Core\UnrealEngineTypes.cs
	 */
	enum EPackageFlags
	{
		PKG_None = 0x00000000,	///< No flags
		PKG_NewlyCreated = 0x00000001,	///< Newly created package, not saved yet. In editor only.
		PKG_ClientOptional = 0x00000002,	///< Purely optional for clients.
		PKG_ServerSideOnly = 0x00000004,   ///< Only needed on the server side.
		PKG_CompiledIn = 0x00000010,   ///< This package is from "compiled in" classes.
		PKG_ForDiffing = 0x00000020,	///< This package was loaded just for the purposes of diffing
		PKG_EditorOnly = 0x00000040,	///< This is editor-only package (for example: editor module script package)
		PKG_Developer = 0x00000080,	///< Developer module
		PKG_UncookedOnly = 0x00000100,	///< Loaded only in uncooked builds (i.e. runtime in editor)
		PKG_Cooked = 0x00000200,	///< Package is cooked
		PKG_ContainsNoAsset = 0x00000400,	///< Package doesn't contain any asset object (although asset tags can be present)
		PKG_NotExternallyReferenceable = 0x00000800,   ///< Objects in this package cannot be referenced in a different plugin or mount point (i.e /Game -> /Engine)
		//	PKG_Unused						= 0x00001000,
		PKG_UnversionedProperties = 0x00002000,   ///< Uses unversioned property serialization instead of versioned tagged property serialization
		PKG_ContainsMapData = 0x00004000,   ///< Contains map data (UObjects only referenced by a single ULevel) but is stored in a different package
		PKG_IsSaving = 0x00008000,	///< Temporarily set on a package while it is being saved.
		PKG_Compiling = 0x00010000,	///< package is currently being compiled
		PKG_ContainsMap = 0x00020000,	///< Set if the package contains a ULevel/ UWorld object
		PKG_RequiresLocalizationGather = 0x00040000,	///< Set if the package contains any data to be gathered by localization
		//	PKG_Unused						= 0x00080000,
		PKG_PlayInEditor = 0x00100000,	///< Set if the package was created for the purpose of PIE
		PKG_ContainsScript = 0x00200000,	///< Package is allowed to contain UClass objects
		PKG_DisallowExport = 0x00400000,	///< Editor should not export asset in this package
		//	PKG_Unused						= 0x00800000,
		//	PKG_Unused						= 0x01000000,
		//	PKG_Unused						= 0x02000000,
		//	PKG_Unused						= 0x04000000,
		PKG_CookGenerated = 0x08000000,	///< This package was generated by the cooker and does not exist in the WorkspaceDomain
		PKG_DynamicImports = 0x10000000,	///< This package should resolve dynamic imports from its export at runtime.
		PKG_RuntimeGenerated = 0x20000000,	///< This package contains elements that are runtime generated, and may not follow standard loading order rules
		PKG_ReloadingForCooker = 0x40000000,   ///< This package is reloading in the cooker, try to avoid getting data we will never need. We won't save this package.
		PKG_FilterEditorOnly = 0x80000000,	///< Package has editor-only data filtered out

		// Transient Flags are cleared when serializing to or from PackageFileSummary
		PKG_TransientFlags = PKG_NewlyCreated | PKG_IsSaving | PKG_ReloadingForCooker,
	};

	/**
	 * Flags describing an object instance
	 */
	enum EObjectFlags
	{
		// Do not add new flags unless they truly belong here. There are alternatives.
		// if you change any the bit of any of the RF_Load flags, then you will need legacy serialization
		RF_NoFlags = 0x00000000,	///< No flags, used to avoid a cast

		// This first group of flags mostly has to do with what kind of object it is. Other than transient, these are the persistent object flags.
		// The garbage collector also tends to look at these.
		RF_Public = 0x00000001,	///< Object is visible outside its package.
		RF_Standalone = 0x00000002,	///< Keep object around for editing even if unreferenced.
		RF_MarkAsNative = 0x00000004,	///< Object (UField) will be marked as native on construction (DO NOT USE THIS FLAG in HasAnyFlags() etc)
		RF_Transactional = 0x00000008,	///< Object is transactional.
		RF_ClassDefaultObject = 0x00000010,	///< This object is its class's default object
		RF_ArchetypeObject = 0x00000020,	///< This object is a template for another object - treat like a class default object
		RF_Transient = 0x00000040,	///< Don't save object.

		// This group of flags is primarily concerned with garbage collection.
		RF_MarkAsRootSet = 0x00000080,	///< Object will be marked as root set on construction and not be garbage collected, even if unreferenced (DO NOT USE THIS FLAG in HasAnyFlags() etc)
		RF_TagGarbageTemp = 0x00000100,	///< This is a temp user flag for various utilities that need to use the garbage collector. The garbage collector itself does not interpret it.

		// The group of flags tracks the stages of the lifetime of a uobject
		RF_NeedInitialization = 0x00000200,	///< This object has not completed its initialization process. Cleared when ~FObjectInitializer completes
		RF_NeedLoad = 0x00000400,	///< During load, indicates object needs loading.
		RF_KeepForCooker = 0x00000800,	///< Keep this object during garbage collection because it's still being used by the cooker
		RF_NeedPostLoad = 0x00001000,	///< Object needs to be postloaded.
		RF_NeedPostLoadSubobjects = 0x00002000,	///< During load, indicates that the object still needs to instance subobjects and fixup serialized component references
		RF_NewerVersionExists = 0x00004000,	///< Object has been consigned to oblivion due to its owner package being reloaded, and a newer version currently exists
		RF_BeginDestroyed = 0x00008000,	///< BeginDestroy has been called on the object.
		RF_FinishDestroyed = 0x00010000,	///< FinishDestroy has been called on the object.

		// Misc. Flags
		RF_BeingRegenerated = 0x00020000,	///< Flagged on UObjects that are used to create UClasses (e.g. Blueprints) while they are regenerating their UClass on load (See FLinkerLoad::CreateExport()), as well as UClass objects in the midst of being created
		RF_DefaultSubObject = 0x00040000,	///< Flagged on subobjects that are defaults
		RF_WasLoaded = 0x00080000,	///< Flagged on UObjects that were loaded
		RF_TextExportTransient = 0x00100000,	///< Do not export object to text form (e.g. copy/paste). Generally used for sub-objects that can be regenerated from data in their parent object.
		RF_LoadCompleted = 0x00200000,	///< Object has been completely serialized by linkerload at least once. DO NOT USE THIS FLAG, It should be replaced with RF_WasLoaded.
		RF_InheritableComponentTemplate = 0x00400000, ///< Archetype of the object can be in its super class
		RF_DuplicateTransient = 0x00800000,	///< Object should not be included in any type of duplication (copy/paste, binary duplication, etc.)
		RF_StrongRefOnFrame = 0x01000000,	///< References to this object from persistent function frame are handled as strong ones.
		RF_NonPIEDuplicateTransient = 0x02000000,	///< Object should not be included for duplication unless it's being duplicated for a PIE session
		RF_Dynamic /*UE_DEPRECATED(5.0, "RF_Dynamic should no longer be used. It is no longer being set by engine code.")*/ = 0x04000000,	///< Field Only. Dynamic field - doesn't get constructed during static initialization, can be constructed multiple times  // @todo: BP2CPP_remove
		RF_WillBeLoaded = 0x08000000,	///< This object was constructed during load and will be loaded shortly
		RF_HasExternalPackage = 0x10000000,	///< This object has an external package assigned and should look it up when getting the outermost package

		// RF_Garbage and RF_PendingKill are mirrored in EInternalObjectFlags because checking the internal flags is much faster for the Garbage Collector
		// while checking the object flags is much faster outside of it where the Object pointer is already available and most likely cached.
		// RF_PendingKill is mirrored in EInternalObjectFlags because checking the internal flags is much faster for the Garbage Collector
		// while checking the object flags is much faster outside of it where the Object pointer is already available and most likely cached.

		RF_PendingKill /*UE_DEPRECATED(5.0, "RF_PendingKill should not be used directly. Make sure references to objects are released using one of the existing engine callbacks or use weak object pointers.")*/ = 0x20000000,	///< Objects that are pending destruction (invalid for gameplay but valid objects). This flag is mirrored in EInternalObjectFlags as PendingKill for performance
		RF_Garbage /*UE_DEPRECATED(5.0, "RF_Garbage should not be used directly. Use MarkAsGarbage and ClearGarbage instead.")*/ = 0x40000000,	///< Garbage from logical point of view and should not be referenced. This flag is mirrored in EInternalObjectFlags as Garbage for performance
		RF_AllocatedInSharedPage = 0x80000000	///< Allocated from a ref-counted page shared with other UObjects
	};

	/**
	 * Objects flags for internal use (GC, low level UObject code)
	*
	* This MUST be kept in sync with EInternalObjectFlags defined in
	* Engine\Source\Programs\Shared\EpicGames.Core\UnrealEngineTypes.cs
	*/
	enum class EInternalObjectFlags : int32
	{
		None = 0,

		LoaderImport = 1 << 20, ///< Object is ready to be imported by another package during loading
		Garbage = 1 << 21, ///< Garbage from logical point of view and should not be referenced. This flag is mirrored in EObjectFlags as RF_Garbage for performance
		PersistentGarbage = 1 << 22, ///< Same as above but referenced through a persistent reference so it can't be GC'd
		ReachableInCluster = 1 << 23, ///< External reference to object in cluster exists
		ClusterRoot = 1 << 24, ///< Root of a cluster
		Native = 1 << 25, ///< Native (UClass only).
		Async = 1 << 26, ///< Object exists only on a different thread than the game thread.
		AsyncLoading = 1 << 27, ///< Object is being asynchronously loaded.
		Unreachable = 1 << 28, ///< Object is not reachable on the object graph.
		PendingKill /*UE_DEPRECATED(5.0, "PendingKill flag should no longer be used. Use Garbage flag instead.")*/ = 1 << 29, ///< Objects that are pending destruction (invalid for gameplay but valid objects). This flag is mirrored in EObjectFlags as RF_PendingKill for performance
		RootSet = 1 << 30, ///< Object will not be garbage collected, even if unreferenced.
		PendingConstruction = 1 << 31, ///< Object didn't have its class constructor called yet (only the UObjectBase one to initialize its most basic members)

		GarbageCollectionKeepFlags = Native | Async | AsyncLoading | LoaderImport,
		MirroredFlags = Garbage | PendingKill, /// Flags mirrored in EObjectFlags

		//~ Make sure this is up to date!
		AllFlags = LoaderImport | Garbage | PersistentGarbage | ReachableInCluster | ClusterRoot | Native | Async | AsyncLoading | Unreachable | PendingKill | RootSet | PendingConstruction
	};

	/**
	 * Single item in UObjectStore
	 */
	struct FUObjectItem
	{
		// Pointer to the allocated object
		class UObjectBase* m_Object;

		// Internal Flags
		int32_t m_InternalFlags;

		FUObjectItem() : m_Object(nullptr), m_InternalFlags(0)
		{
		}

		// Non-copyable
		FUObjectItem(FUObjectItem&&) = delete;
		FUObjectItem(const FUObjectItem&) = delete;
		FUObjectItem& operator=(FUObjectItem&&) = delete;
		FUObjectItem& operator=(const FUObjectItem&) = delete;

		// digression from ue, from threadatomicallysetflag
		FORCEINLINE void SetFlags(EInternalObjectFlags FlagsToSet)
		{
			KR_CORE_ASSERT((int32_t(FlagsToSet) & ~int32_t(EInternalObjectFlags::AllFlags)) == 0, "");

			m_InternalFlags = int32_t(FlagsToSet);
		}

		FORCEINLINE EInternalObjectFlags GetFlags() const
		{
			//return FPlatformAtomics::AtomicRead_Relaxed((int32*)&Flags);
			return EInternalObjectFlags(m_InternalFlags);
		}

		FORCEINLINE bool HasAnyFlags(EInternalObjectFlags InFlags) const
		{
				return !!(m_InternalFlags & int32_t(InFlags));
		}
	};

	/**
	 * A class for managing the collection of UObjects (all or some?)
	 *
	 * Note from UE devlopers (for the class FUObjectArray):
	 * Note the layout of this data structure is mostly to emulate the old behavior and minimize code rework during code restructure.
	 * Better data structures could be used in the future, for example maybe all that is needed is a TSet<UObject *>
	 * One has to be a little careful with this, especially with the GC optimization. I have seen spots that assume
	 * that non-GC objects come before GC ones during iteration.
	 */
	class KARMA_API FUObjectArray : public KarmaVector<FUObjectItem*>
	{
	public:
		/**
		 * Low level iterator.
		 */
		class TIterator
		{
		public:
			enum EEndTagType
			{
				EndTag
			};

			/**
			 * Constructor
			 *
			 * @param	InArray				the array to iterate on
			 * @param	bOnlyGCedObjects	if true, skip all of the permanent objects
			 */
			TIterator(const FUObjectArray& InArray, bool bOnlyGCedObjects = false) :
				m_Array(InArray),
				m_Index(-1),
				m_CurrentObject(nullptr)
			{
				if (bOnlyGCedObjects)
				{
					//m_Index = m_Array.ObjLastNonGCIndex;
				}
				Advance();
			}

			/**
			 * Constructor
			 *
			 * @param	InArray				the array to iterate on
			 * @param	bOnlyGCedObjects	if true, skip all of the permanent objects
			 */
			TIterator(EEndTagType, const TIterator& InIter) :
				m_Array(InIter.m_Array)
			{
				m_Index = m_Array.Num();
			}

			/**
			 * Iterator advance
			 */
			FORCEINLINE void operator++()
			{
				Advance();
			}

			bool operator==(const TIterator& Rhs) const { return m_Index == Rhs.m_Index; }
			bool operator!=(const TIterator& Rhs) const { return m_Index != Rhs.m_Index; }

			/** Conversion to "bool" returning true if the iterator is valid. */
			FORCEINLINE explicit operator bool() const
			{
				return !!m_CurrentObject;
			}
			/** inverse of the "bool" operator */
			FORCEINLINE bool operator !() const
			{
				return !(bool)*this;
			}

			FORCEINLINE int32 GetIndex() const
			{
				return m_Index;
			}

		protected:

			/**
			 * Dereferences the iterator with an ordinary name for clarity in derived classes
			 *
			 * @return	the UObject at the iterator
			 */
			FORCEINLINE FUObjectItem* GetObject() const
			{
				return m_CurrentObject;
			}

			/**
			 * Iterator advance with ordinary name for clarity in subclasses
			 * @return	true if the iterator points to a valid object, false if iteration is complete
			 */
			FORCEINLINE bool Advance()
			{
				//@todo UE check this for LHS on Index on consoles
				FUObjectItem* NextObject = nullptr;
				m_CurrentObject = nullptr;
				while(++m_Index < m_Array.GetObjectsList().size())
				{
					NextObject = m_Array.GetObjectsList()[m_Index];
					if (NextObject->m_Object)
					{
						m_CurrentObject = NextObject;
						return true;
					}
				}
				return false;
			}

			/** Gets the array this iterator iterates over */
			const FUObjectArray& GetIteratedArray() const
			{
				return m_Array;
			}

		private:
			/** the array that we are iterating on, probably always GUObjectArray */
			const FUObjectArray& m_Array;
			/** index of the current element in the object array */
			int32_t m_Index;

			/** Current object */
			mutable FUObjectItem* m_CurrentObject;
		};

	public:
		/** Add an element to the list*/
		// Maybe use pool allocations instead of new delete operators for optimization
		void AddUObject(UObject* Object);

		/** Retrieve the list of the UObjects */
		const std::vector<FUObjectItem*>& GetObjectsList() const { return m_Elements; }
	};

	class KarmaClassObjectMap : public KarmaMap<UClass*, KarmaVector<UObject*>*>
	{
	public:
		KarmaClassObjectMap()
		{}

		~KarmaClassObjectMap();

		/**
		 * Find the object vector associated with class
		 *
		 * @param Key The key to search for.
		 * @return A pointer to the object vector
		 */
		KarmaVector<UObject*>* FindClassObjects(const UClass* Key);

		/**
		 * Find the value associated with a specified key, or if none exists,
		 * adds a value using the default constructor.
		 *
		 * @param Key The key to search for.
		 * @return A reference to the value associated with the specified key.
		 */
		KarmaVector<UObject*>* FindOrAddClass(const UClass* Key);
	};

	/**
	 * Global UObject array instance
	 * All the UObjects created are to be found in this store. Analogoue to GUObjectArray of UE, defined in UObjectHash.cpp
	 * A note on GUObjectArray
	 * https://forums.unrealengine.com/t/how-to-register-disregard-for-gc-objects/264991
	 */
	extern KARMA_API FUObjectArray GUObjectStore;

	/**
	 * A cache of UClass and UObjects maps for quick lookup of objects
	 * by class.
	 *
	 * Global public variable because UE has so FUObjectHashTables::ClassToObjectListMap. Think about
	 * access specifier.
	 *
	 * Please note: Unreal Engine uses more complex TBucketMap<UClass*> ClassToObjectListMap for
	 * caching the objects by class
	 */
	extern KARMA_API KarmaClassObjectMap m_ClassToObjectVectorMap;

	/**
	* This struct is used for passing parameter values to the StaticConstructObject_Internal() method.  Only the constructor parameters are required to
	* be valid - all other members are optional.
	*/
	struct FStaticConstructObjectParameters
	{
		/** The class of the object to create */
		const UClass* m_Class;

		/** The object to create this object within (the Outer property for the new object will be set to the value specified here). */
		UObject* m_Outer;

		/** The name to give the new object.If no value(NAME_None) is specified, the object will be given a unique name in the form of ClassName_#. */
		std::string m_Name;

		/** The ObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object. */
		EObjectFlags m_SetFlags = EObjectFlags::RF_NoFlags;

		/** The InternalObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object. */
		EInternalObjectFlags m_InternalSetFlags = EInternalObjectFlags::None;

		/** If true, copy transient from the class defaults instead of the pass in archetype ptr(often these are the same) */
		bool m_bCopyTransientsFromClassDefaults = false;

		/** If true, Template is guaranteed to be an archetype */
		bool m_bAssumeTemplateIsArchetype = false;

		/**
		 * If specified, the property values from this object will be copied to the new object, and the new object's ObjectArchetype value will be set to this object.
		 * If nullptr, the class default object is used instead.
		 */
		UObject* m_Template = nullptr;

		/** Contains the mappings of instanced objects and components to their templates */
		//FObjectInstancingGraph* InstanceGraph = nullptr;

		/** Assign an external Package to the created object if non-null */
		//UPackage* ExternalPackage = nullptr;

		/** Callback for custom code to initialize properties before PostInitProperties runs */
		//TFunction<void()> PropertyInitCallback;

		/** Contains the mappings of instanced objects and components to their templates */
		//FObjectInstancingGraph* InstanceGraph = nullptr;

	private:
		//FObjectInitializer::FOverrides* SubobjectOverrides = nullptr;

	public:

		//COREUOBJECT_API FStaticConstructObjectParameters(const UClass* InClass);

		//friend FObjectInitializer;
	};

/** Parameter enum for CastChecked() function, defines when it will check/assert */
namespace ECastCheckedType
{
	enum Type
	{
		/** Null is okay, only assert on incorrect type */
		NullAllowed,
		/** Null is not allowed, assert on incorrect type or null */
		NullChecked
	};
};

/**
 * Sees if class of type U can be cast into T class type, returns the casted class
 * Needs to move to own Cast class
 *
 * @param Src					The object pointer which needs to be checked
 * @param CheckType				How to perform cast checks
 */
template <class T, class U>
FORCEINLINE T* CastChecked(const U& Src, ECastCheckedType::Type CheckType = ECastCheckedType::NullChecked)
{
	if (Src)
	{
		T* Result = static_cast<T*>(Src);// this line may need some generalization, I will come back later
		if (!Result)
		{
			KR_CORE_ERROR("Casting failed");
		}

		return Result;
	}

	if (CheckType == ECastCheckedType::NullChecked)
	{
		KR_CORE_ASSERT(false, "Attempting to cast nullptr");
	}

	return nullptr;
}

/**
 * Create a new instance of an object.  The returned object will be fully initialized.  If InFlags contains RF_NeedsLoad (indicating that the object still needs to load its object data from disk), components
 * are not instanced (this will instead occur in PostLoad()).  The different between StaticConstructObject and StaticAllocateObject is that StaticConstructObject will also call the class constructor on the object
 * and instance any components.
 *
 * @param	Params		The parameters to use when construction the object. @see FStaticConstructObjectParameters
 *
 * @return	A pointer to a fully initialized object of the specified class.
 */
KARMA_API UObject* StaticConstructObject_Internal(const FStaticConstructObjectParameters& Params);

/**
 * Create a new instance of an object or replace an existing object.  If both an Outer and Name are specified, and there is an object already in memory with the same Class, Outer, and Name, the
 * existing object will be destructed, and the new object will be created in its place.
 *
 * @param	Class		the class of the object to create
 * @param	InOuter		the object to create this object within (the Outer property for the new object will be set to the value specified here).
 * @param	Name		the name to give the new object. If no value (NAME_None) is specified, the object will be given a unique name in the form of ClassName_#.
 * @param	SetFlags	the ObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object.
 * @param InternalSetFlags	the InternalObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object.
 *
 * Rest shall be made available when reflection code is enabled
 * @param bCanReuseSubobjects	if set to true, SAO will not attempt to destroy a subobject if it already exists in memory.
 * @param bOutReusedSubobject	flag indicating if the object is a subobject that has already been created (in which case further initialization is not necessary).
 * @param ExternalPackage	External Package assigned to the allocated object, if any
 * @return	a pointer to a fully initialized object of the specified class.
 */
KARMA_API UObject* StaticAllocateObject(const UClass* Class, UObject* InOuter, const std::string& name, EObjectFlags SetFlags = EObjectFlags::RF_NoFlags, EInternalObjectFlags InternalSetFlags = EInternalObjectFlags::None);


/**
 * Convenience template for constructing a gameplay object
 *
 * @param	Outer		the outer for the new object.  If not specified, object will be created in the transient package. For AActors, Outer is the ULevel
 * @param	Class		the class of object to construct
 * @param	Name		the name for the new object.  If not specified, the object will be given a transient name via MakeUniqueObjectName
 * @param	Flags		the object flags to apply to the new object
 * @param	Template	the object to use for initializing the new object.  If not specified, the class's default object will be used. Not functional atm
 * @param	bCopyTransientsFromClassDefaults	if true, copy transient from the class defaults instead of the pass in archetype ptr (often these are the same)
 * @param	InInstanceGraph						contains the mappings of instanced objects and components to their templates
 * @param	ExternalPackage						Assign an external Package to the created object if non-null
 *
 * @return	a pointer of type T to a new object of the specified class
 */
template< class T >
FUNCTION_NON_NULL_RETURN_START
T* NewObject(UObject* Outer, const UClass* Class, std::string name = "No_Name", EObjectFlags Flags = RF_NoFlags, UObject* Template = nullptr, bool bCopyTransientsFromClassDefaults = false/*, FObjectInstancingGraph* InInstanceGraph = nullptr, UPackage* ExternalPackage = nullptr*/)
FUNCTION_NON_NULL_RETURN_END
{
	if (name == "")
	{
		KR_CORE_ASSERT(false, "NewObject with empty name can't be used to create default subobjects");
		//FObjectInitializer::AssertIfInConstructor(Outer, TEXT("NewObject with empty name can't be used to create default subobjects (inside of UObject derived class constructor) as it produces inconsistent object names. Use ObjectInitializer.CreateDefaultSubobject<> instead."));
	}

	FStaticConstructObjectParameters Params;
	Params.m_Class = Class;
	Params.m_Outer = Outer;
	Params.m_Name = name;
	Params.m_SetFlags = Flags;
	Params.m_Class = Class;
	//Params.m_Template = Template;
	Params.m_bCopyTransientsFromClassDefaults = bCopyTransientsFromClassDefaults;
	//Params.InstanceGraph = InInstanceGraph;
	//Params.ExternalPackage = ExternalPackage;

	return static_cast<T*>(StaticConstructObject_Internal(Params));
}
/*
template< class T >
FUNCTION_NON_NULL_RETURN_START*/
//T* NewObject(UObject* Outer, const std::string& Name, EObjectFlags Flags = RF_NoFlags, UObject* Template = nullptr, bool bCopyTransientsFromClassDefaults = false/*, FObjectInstancingGraph* InInstanceGraph = nullptr*/)
/*FUNCTION_NON_NULL_RETURN_END
{
	if (Name == "")
	{
		KR_CORE_ASSERT(false, "NewObject with empty name can't be used to create default subobjects");
		//FObjectInitializer::AssertIfInConstructor(Outer, TEXT("NewObject with empty name can't be used to create default subobjects (inside of UObject derived class constructor) as it produces inconsistent object names. Use ObjectInitializer.CreateDefaultSubobject<> instead."));
	}

	FStaticConstructObjectParameters Params;// (T::StaticClass());
	Params.m_Outer = Outer;
	Params.m_Name = Name;
	Params.m_SetFlags = Flags;
	//Params.Template = Template;
	Params.m_bCopyTransientsFromClassDefaults = bCopyTransientsFromClassDefaults;
	Params.m_Class = T::StaticClass<T>();
	//Params.InstanceGraph = InInstanceGraph;

	return static_cast<T*>(StaticConstructObject_Internal(Params));
}*/

/**
 * A routine to find if the object is instantiated already. May need to modify in accordance with thread safety in future
 * UE name StaticFindObjectFastInternal
 *
 * @param	ObjectClass			the class of object to construct
 * @param	ObjectPackage		the outer where the object is supposed to be found
 * @param	ObjectName			the name for the object to be found
 * @param	bExactClass			class match check
 * @param	bAnyPackage			If there is no package (no InObjectPackage specified, and InName's package is "") and the caller specified any_package, then
 *								accept it, regardless of its package.Or, if the object is a top-level package then accept it immediately
 * @param	ExcludeFlags		Don't return objects that have any of these exclusive flags set
 * @param	ExclusiveInternalFlags			Include (or not) pending kill objects
 * @param	ExternalPackage					Assign an external Package to the created object if non-null
 *
 * @return	a pointer of type UObject if found, else nulptr
 */
KARMA_API UObject* StaticFindObjectFastInternal(const UClass* ObjectClass, const UObject* ObjectPackage, const std::string& ObjectName, bool bExactClass = false, EObjectFlags ExcludeFlags = RF_NoFlags, EInternalObjectFlags ExclusiveInternalFlags = EInternalObjectFlags::None);

/**
 * Find an existing package by name or create it if it doesn't exist
 * @return The existing package or a newly created one
 *
 */
KARMA_API UPackage* CreatePackage(const std::string& PackageName);

/**
 * Returns a vector of objects of a specific class. Optionally, results can include objects of derived classes as well.
 *
 * bIncludeDerivedClasses not functional yet
 *
 * @param	ClassToLookFor				Class of the objects to return.
 * @param	Results						An output list of objects of the specified class.
 * @param	bIncludeDerivedClasses		If true, the results will include objects of child classes as well.
 * @param	AdditionalExcludeFlags		Objects with any of these flags will be excluded from the results.
 * @param	ExclusiveInternalFlags	Specifies internal flags to use as a filter for which objects to return
 */
KARMA_API void GetObjectsOfClass(const UClass* ClassToLookFor, KarmaVector<UObject *>& Results, bool bIncludeDerivedClasses = true, EObjectFlags ExcludeFlags = RF_ClassDefaultObject, EInternalObjectFlags ExclusionInternalFlags = EInternalObjectFlags::None);

/**
 * Performs an operation on all objects of the provided class
 * Note that the operation must not modify UObject hash maps so it can not create, rename, or destroy UObjects.
 *
 * @param	Outer						UObject class to loop over instances of
 * @param	Operation					Function to be called for each object
 * @param	bIncludeDerivedClasses		If true, the results will include objects of child classes as well.
 * @param	AdditionalExcludeFlags		Objects with any of these flags will be excluded from the results.
 */
KARMA_API void ForEachObjectOfClass(const UClass* ClassToLookFor, std::function<void(UObject*)> Operation, bool bIncludeDerivedClasses = true, EObjectFlags ExcludeFlags = RF_ClassDefaultObject, EInternalObjectFlags ExclusionInternalFlags = EInternalObjectFlags::None);

/**
 * For UObjects statistics
 */
typedef void (*FUObjectAllocatorCallback)(void* InObject, const std::string& InName, size_t InSize, size_t InAlignment, class UClass* InClass);

/**
 * Client's callback registering routine for receiving UObjects relevant
 * data dump
 *
 * @param dumpCallback The callback function defined in client
 */
KARMA_API extern void RegisterUObjectsStatisticsCallback(FUObjectAllocatorCallback dumpCallback);


/**
 * Add an object to the cache, categorized by class
 *
 * @param	Object		Object to add to the cache
 * @see m_ClassToObjectVectorMap
 */
KARMA_API void CacheObject(class UObject* Object);

// Global Internal functions
extern void StaticUObjectInit();
extern UPackage* GetTransientPackage();

	/**
	 * Internal class to finalize UObject creation (initialize properties) after the real C++ constructor is called
	 */
	class KARMA_API FObjectInitializer
	{
		public:
			/**
			 * Default Constructor, used when you are using the C++ "new" syntax. UObject::UObject will set the object pointer
			 */
			FObjectInitializer();

			/**
			 * Constructor
			 * @param	InObj object to initialize, from static allocate object, after construction
			 * @param	InObjectArchetype object to initialize properties from
			 * @param	bInCopyTransientsFromClassDefaults - if true, copy transient from the class defaults instead of the pass in archetype ptr (often these are the same)
			 * @param	bInShouldInitializeProps false is a special case for changing base classes in UCCMake
			 * @param	InInstanceGraph passed instance graph
			 */
			FObjectInitializer(UObject* InObj, UObject* InObjectArchetype, bool bInCopyTransientsFromClassDefaults, bool 	bInShouldInitializeProps, struct FObjectInstancingGraph* InInstanceGraph = nullptr);

			~FObjectInitializer();

			/**
			 * Return the object that is being constructed
			 */
			FORCEINLINE UObject* GetObj() const
			{
				return m_Object;
			}

		private:
			friend class UObject;

			template<class T>
			friend void InternalConstructor(const class FObjectInitializer& X);

			/**
			 * Finalizes a constructed UObject by initializing properties,
			 * instancing/initializing sub-objects, etc.
			 */
			void PostConstructInit();

			/**
			 * Binary initialize object properties to zero or defaults.
			 *
			 * @param	Obj					object to initialize data for
			 * @param	DefaultsClass		the class to use for initializing the data
			 * @param	DefaultData			the buffer containing the source data for the initialization
			 * @param	bCopyTransientsFromClassDefaults if true, copy the transients from the DefaultsClass defaults, otherwise copy the transients from DefaultData
			 */
			static void InitProperties(UObject* Object, UClass* DefaultsClass, UObject* DefaultData, bool 	bCopyTransientsFromClassDefaults);

		private:
			/** object to intialize, from static allocate object, after construction */
			UObject* m_Object;

			/** object to copy properties from */
			UObject* m_ObjectArchetype;

			/**  if true, copy the transients from the DefaultsClass defaults, otherwise copy the transients from DefaultData **/
			bool m_bCopyTransientsFromClassDefaults;

			/**  If true, initialize the properties **/
			bool m_bShouldInitializePropsFromArchetype;

			/**  Only true until ObjectInitializer has not reached the base UObject class */
			bool m_bSubobjectClassInitializationAllowed;

			/**  Previously constructed object in the callstack */
			UObject* m_LastConstructedObject;
	};
}
