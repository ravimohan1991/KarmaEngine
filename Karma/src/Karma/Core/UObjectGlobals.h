#pragma once

#include "krpch.h"

namespace Karma
{
	class UObject;
	class AActor;
	class UClass;
	class UPackage;
	//enum EObjectFlags;
	//enum class EInternalObjectFlags;

	/**
	 * Global UObject array instance
	 * All the UObjects created are to be found in this store. Analogoue to GUObjectArray of UE, defined in UObjectHash.cpp
	 * A note on GUObjectArray
	 * https://forums.unrealengine.com/t/how-to-register-disregard-for-gc-objects/264991
	 */
	extern std::vector<UObject*> GUObjectStore;

#define	INVALID_OBJECT	(UObject*)-1

	// 32-bit signed integer <- find or write appropriate class for such type
	typedef signed int	 		int32;

	enum { INDEX_NONE = -1 };

	/**
	 * Flags describing a class.
	 *
	 * This MUST be kept in sync with EClassFlags defined in
	 * Engine\Source\Programs\Shared\EpicGames.Core\UnrealEngineTypes.cs
	 */
	enum EClassFlags
	{
		/** No Flags */
		CLASS_None = 0x00000000u,
		/** Class is abstract and can't be instantiated directly. */
		CLASS_Abstract = 0x00000001u,
		/** Save object configuration only to Default INIs, never to local INIs. Must be combined with CLASS_Config */
		CLASS_DefaultConfig = 0x00000002u,
		/** Load object configuration at construction time. */
		CLASS_Config = 0x00000004u,
		/** This object type can't be saved; null it out at save time. */
		CLASS_Transient = 0x00000008u,
		/** This object type may not be available in certain context. (i.e. game runtime or in certain configuration). Optional class data is saved separately to other object types. (i.e. might use sidecar files) */
		CLASS_Optional = 0x00000010u,
		/** */
		CLASS_MatchedSerializers = 0x00000020u,
		/** Indicates that the config settings for this class will be saved to Project/User*.ini (similar to CLASS_GlobalUserConfig) */
		CLASS_ProjectUserConfig = 0x00000040u,
		/** Class is a native class - native interfaces will have CLASS_Native set, but not RF_MarkAsNative */
		CLASS_Native = 0x00000080u,
		/** Don't export to C++ header. */
		//CLASS_NoExport UE_DEPRECATED(5.1, "CLASS_NoExport should no longer be used. It is no longer being set by engine code.") = 0x00000100u,
		/** Do not allow users to create in the editor. */
		CLASS_NotPlaceable = 0x00000200u,
		/** Handle object configuration on a per-object basis, rather than per-class. */
		CLASS_PerObjectConfig = 0x00000400u,

		/** Whether SetUpRuntimeReplicationData still needs to be called for this class */
		CLASS_ReplicationDataIsSetUp = 0x00000800u,

		/** Class can be constructed from editinline New button. */
		CLASS_EditInlineNew = 0x00001000u,
		/** Display properties in the editor without using categories. */
		CLASS_CollapseCategories = 0x00002000u,
		/** Class is an interface **/
		CLASS_Interface = 0x00004000u,
		/**  Do not export a constructor for this class, assuming it is in the cpptext **/
		//CLASS_CustomConstructor UE_DEPRECATED(5.1, "CLASS_CustomConstructor should no longer be used. It is no longer being set by engine code.") = 0x00008000u,
		/** all properties and functions in this class are const and should be exported as const */
		CLASS_Const = 0x00010000u,

		/** Class flag indicating objects of this class need deferred dependency loading */
		CLASS_NeedsDeferredDependencyLoading = 0x00020000u,

		/** Indicates that the class was created from blueprint source material */
		CLASS_CompiledFromBlueprint = 0x00040000u,

		/** Indicates that only the bare minimum bits of this class should be DLL exported/imported */
		CLASS_MinimalAPI = 0x00080000u,

		/** Indicates this class must be DLL exported/imported (along with all of it's members) */
		CLASS_RequiredAPI = 0x00100000u,

		/** Indicates that references to this class default to instanced. Used to be subclasses of UComponent, but now can be any UObject */
		CLASS_DefaultToInstanced = 0x00200000u,

		/** Indicates that the parent token stream has been merged with ours. */
		CLASS_TokenStreamAssembled = 0x00400000u,
		/** Class has component properties. */
		CLASS_HasInstancedReference = 0x00800000u,
		/** Don't show this class in the editor class browser or edit inline new menus. */
		CLASS_Hidden = 0x01000000u,
		/** Don't save objects of this class when serializing */
		CLASS_Deprecated = 0x02000000u,
		/** Class not shown in editor drop down for class selection */
		CLASS_HideDropDown = 0x04000000u,
		/** Class settings are saved to <AppData>/..../Blah.ini (as opposed to CLASS_DefaultConfig) */
		CLASS_GlobalUserConfig = 0x08000000u,
		/** Class was declared directly in C++ and has no boilerplate generated by UnrealHeaderTool */
		CLASS_Intrinsic = 0x10000000u,
		/** Class has already been constructed (maybe in a previous DLL version before hot-reload). */
		CLASS_Constructed = 0x20000000u,
		/** Indicates that object configuration will not check against ini base/defaults when serialized */
		CLASS_ConfigDoNotCheckDefaults = 0x40000000u,
		/** Class has been consigned to oblivion as part of a blueprint recompile, and a newer version currently exists. */
		CLASS_NewerVersionExists = 0x80000000u,
	};

	/**
	 * Package flags, passed into UPackage::SetPackageFlags and related functions
	 *
	 * This MUST be kept in sync with EPackageFlags defined in
	 * Engine\Source\Programs\Shared\EpicGames.Core\UnrealEngineTypes.cs
	 */
	enum EPackageFlags
	{
		PKG_None = 0x00000000,	///< No flags
		PKG_NewlyCreated = 0x00000001,	///< Newly created package, not saved yet. In editor only.
		PKG_ClientOptional = 0x00000002,	///< Purely optional for clients.
		PKG_ServerSideOnly = 0x00000004,   ///< Only needed on the server side.
		PKG_CompiledIn = 0x00000010,   ///< This package is from "compiled in" classes.
		PKG_ForDiffing = 0x00000020,	///< This package was loaded just for the purposes of diffing
		PKG_EditorOnly = 0x00000040,	///< This is editor-only package (for example: editor module script package)
		PKG_Developer = 0x00000080,	///< Developer module
		PKG_UncookedOnly = 0x00000100,	///< Loaded only in uncooked builds (i.e. runtime in editor)
		PKG_Cooked = 0x00000200,	///< Package is cooked
		PKG_ContainsNoAsset = 0x00000400,	///< Package doesn't contain any asset object (although asset tags can be present)
		PKG_NotExternallyReferenceable = 0x00000800,   ///< Objects in this package cannot be referenced in a different plugin or mount point (i.e /Game -> /Engine)
		//	PKG_Unused						= 0x00001000,
		PKG_UnversionedProperties = 0x00002000,   ///< Uses unversioned property serialization instead of versioned tagged property serialization
		PKG_ContainsMapData = 0x00004000,   ///< Contains map data (UObjects only referenced by a single ULevel) but is stored in a different package
		PKG_IsSaving = 0x00008000,	///< Temporarily set on a package while it is being saved.
		PKG_Compiling = 0x00010000,	///< package is currently being compiled
		PKG_ContainsMap = 0x00020000,	///< Set if the package contains a ULevel/ UWorld object
		PKG_RequiresLocalizationGather = 0x00040000,	///< Set if the package contains any data to be gathered by localization
		//	PKG_Unused						= 0x00080000,
		PKG_PlayInEditor = 0x00100000,	///< Set if the package was created for the purpose of PIE
		PKG_ContainsScript = 0x00200000,	///< Package is allowed to contain UClass objects
		PKG_DisallowExport = 0x00400000,	///< Editor should not export asset in this package
		//	PKG_Unused						= 0x00800000,
		//	PKG_Unused						= 0x01000000,	
		//	PKG_Unused						= 0x02000000,	
		//	PKG_Unused						= 0x04000000,
		PKG_CookGenerated = 0x08000000,	///< This package was generated by the cooker and does not exist in the WorkspaceDomain
		PKG_DynamicImports = 0x10000000,	///< This package should resolve dynamic imports from its export at runtime.
		PKG_RuntimeGenerated = 0x20000000,	///< This package contains elements that are runtime generated, and may not follow standard loading order rules
		PKG_ReloadingForCooker = 0x40000000,   ///< This package is reloading in the cooker, try to avoid getting data we will never need. We won't save this package.
		PKG_FilterEditorOnly = 0x80000000,	///< Package has editor-only data filtered out

		// Transient Flags are cleared when serializing to or from PackageFileSummary
		PKG_TransientFlags = PKG_NewlyCreated | PKG_IsSaving | PKG_ReloadingForCooker,
	};

	/**
	 * Flags describing an object instance
	 */
	enum EObjectFlags
	{
		// Do not add new flags unless they truly belong here. There are alternatives.
		// if you change any the bit of any of the RF_Load flags, then you will need legacy serialization
		RF_NoFlags = 0x00000000,	///< No flags, used to avoid a cast

		// This first group of flags mostly has to do with what kind of object it is. Other than transient, these are the persistent object flags.
		// The garbage collector also tends to look at these.
		RF_Public = 0x00000001,	///< Object is visible outside its package.
		RF_Standalone = 0x00000002,	///< Keep object around for editing even if unreferenced.
		RF_MarkAsNative = 0x00000004,	///< Object (UField) will be marked as native on construction (DO NOT USE THIS FLAG in HasAnyFlags() etc)
		RF_Transactional = 0x00000008,	///< Object is transactional.
		RF_ClassDefaultObject = 0x00000010,	///< This object is its class's default object
		RF_ArchetypeObject = 0x00000020,	///< This object is a template for another object - treat like a class default object
		RF_Transient = 0x00000040,	///< Don't save object.

		// This group of flags is primarily concerned with garbage collection.
		RF_MarkAsRootSet = 0x00000080,	///< Object will be marked as root set on construction and not be garbage collected, even if unreferenced (DO NOT USE THIS FLAG in HasAnyFlags() etc)
		RF_TagGarbageTemp = 0x00000100,	///< This is a temp user flag for various utilities that need to use the garbage collector. The garbage collector itself does not interpret it.

		// The group of flags tracks the stages of the lifetime of a uobject
		RF_NeedInitialization = 0x00000200,	///< This object has not completed its initialization process. Cleared when ~FObjectInitializer completes
		RF_NeedLoad = 0x00000400,	///< During load, indicates object needs loading.
		RF_KeepForCooker = 0x00000800,	///< Keep this object during garbage collection because it's still being used by the cooker
		RF_NeedPostLoad = 0x00001000,	///< Object needs to be postloaded.
		RF_NeedPostLoadSubobjects = 0x00002000,	///< During load, indicates that the object still needs to instance subobjects and fixup serialized component references
		RF_NewerVersionExists = 0x00004000,	///< Object has been consigned to oblivion due to its owner package being reloaded, and a newer version currently exists
		RF_BeginDestroyed = 0x00008000,	///< BeginDestroy has been called on the object.
		RF_FinishDestroyed = 0x00010000,	///< FinishDestroy has been called on the object.

		// Misc. Flags
		RF_BeingRegenerated = 0x00020000,	///< Flagged on UObjects that are used to create UClasses (e.g. Blueprints) while they are regenerating their UClass on load (See FLinkerLoad::CreateExport()), as well as UClass objects in the midst of being created
		RF_DefaultSubObject = 0x00040000,	///< Flagged on subobjects that are defaults
		RF_WasLoaded = 0x00080000,	///< Flagged on UObjects that were loaded
		RF_TextExportTransient = 0x00100000,	///< Do not export object to text form (e.g. copy/paste). Generally used for sub-objects that can be regenerated from data in their parent object.
		RF_LoadCompleted = 0x00200000,	///< Object has been completely serialized by linkerload at least once. DO NOT USE THIS FLAG, It should be replaced with RF_WasLoaded.
		RF_InheritableComponentTemplate = 0x00400000, ///< Archetype of the object can be in its super class
		RF_DuplicateTransient = 0x00800000,	///< Object should not be included in any type of duplication (copy/paste, binary duplication, etc.)
		RF_StrongRefOnFrame = 0x01000000,	///< References to this object from persistent function frame are handled as strong ones.
		RF_NonPIEDuplicateTransient = 0x02000000,	///< Object should not be included for duplication unless it's being duplicated for a PIE session
		RF_Dynamic /*UE_DEPRECATED(5.0, "RF_Dynamic should no longer be used. It is no longer being set by engine code.")*/ = 0x04000000,	///< Field Only. Dynamic field - doesn't get constructed during static initialization, can be constructed multiple times  // @todo: BP2CPP_remove
		RF_WillBeLoaded = 0x08000000,	///< This object was constructed during load and will be loaded shortly
		RF_HasExternalPackage = 0x10000000,	///< This object has an external package assigned and should look it up when getting the outermost package

		// RF_Garbage and RF_PendingKill are mirrored in EInternalObjectFlags because checking the internal flags is much faster for the Garbage Collector
		// while checking the object flags is much faster outside of it where the Object pointer is already available and most likely cached.
		// RF_PendingKill is mirrored in EInternalObjectFlags because checking the internal flags is much faster for the Garbage Collector
		// while checking the object flags is much faster outside of it where the Object pointer is already available and most likely cached.

		RF_PendingKill /*UE_DEPRECATED(5.0, "RF_PendingKill should not be used directly. Make sure references to objects are released using one of the existing engine callbacks or use weak object pointers.")*/ = 0x20000000,	///< Objects that are pending destruction (invalid for gameplay but valid objects). This flag is mirrored in EInternalObjectFlags as PendingKill for performance
		RF_Garbage /*UE_DEPRECATED(5.0, "RF_Garbage should not be used directly. Use MarkAsGarbage and ClearGarbage instead.")*/ = 0x40000000,	///< Garbage from logical point of view and should not be referenced. This flag is mirrored in EInternalObjectFlags as Garbage for performance
		RF_AllocatedInSharedPage = 0x80000000	///< Allocated from a ref-counted page shared with other UObjects
	};

	/**
	 * Objects flags for internal use (GC, low level UObject code)
	*
	* This MUST be kept in sync with EInternalObjectFlags defined in
	* Engine\Source\Programs\Shared\EpicGames.Core\UnrealEngineTypes.cs
	*/
	enum class EInternalObjectFlags : int32
	{
		None = 0,

		LoaderImport = 1 << 20, ///< Object is ready to be imported by another package during loading
		Garbage = 1 << 21, ///< Garbage from logical point of view and should not be referenced. This flag is mirrored in EObjectFlags as RF_Garbage for performance
		PersistentGarbage = 1 << 22, ///< Same as above but referenced through a persistent reference so it can't be GC'd
		ReachableInCluster = 1 << 23, ///< External reference to object in cluster exists
		ClusterRoot = 1 << 24, ///< Root of a cluster
		Native = 1 << 25, ///< Native (UClass only). 
		Async = 1 << 26, ///< Object exists only on a different thread than the game thread.
		AsyncLoading = 1 << 27, ///< Object is being asynchronously loaded.
		Unreachable = 1 << 28, ///< Object is not reachable on the object graph.
		PendingKill /*UE_DEPRECATED(5.0, "PendingKill flag should no longer be used. Use Garbage flag instead.")*/ = 1 << 29, ///< Objects that are pending destruction (invalid for gameplay but valid objects). This flag is mirrored in EObjectFlags as RF_PendingKill for performance
		RootSet = 1 << 30, ///< Object will not be garbage collected, even if unreferenced.
		PendingConstruction = 1 << 31, ///< Object didn't have its class constructor called yet (only the UObjectBase one to initialize its most basic members)

		GarbageCollectionKeepFlags = Native | Async | AsyncLoading | LoaderImport,
		MirroredFlags = Garbage | PendingKill, /// Flags mirrored in EObjectFlags

		//~ Make sure this is up to date!
		AllFlags = LoaderImport | Garbage | PersistentGarbage | ReachableInCluster | ClusterRoot | Native | Async | AsyncLoading | Unreachable | PendingKill | RootSet | PendingConstruction
	};

	/**
	* This struct is used for passing parameter values to the StaticConstructObject_Internal() method.  Only the constructor parameters are required to
	* be valid - all other members are optional.
	*/
	struct FStaticConstructObjectParameters
	{
		/** The class of the object to create */
		const UClass* m_Class;

		/** The object to create this object within (the Outer property for the new object will be set to the value specified here). */
		UObject* m_Outer;

		/** The name to give the new object.If no value(NAME_None) is specified, the object will be given a unique name in the form of ClassName_#. */
		std::string m_Name;

		/** The ObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object. */
		EObjectFlags m_SetFlags = EObjectFlags::RF_NoFlags;

		/** The InternalObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object. */
		EInternalObjectFlags m_InternalSetFlags = EInternalObjectFlags::None;

		/** If true, copy transient from the class defaults instead of the pass in archetype ptr(often these are the same) */
		bool m_bCopyTransientsFromClassDefaults = false;

		/** If true, Template is guaranteed to be an archetype */
		bool m_bAssumeTemplateIsArchetype = false;

		/**
		 * If specified, the property values from this object will be copied to the new object, and the new object's ObjectArchetype value will be set to this object.
		 * If nullptr, the class default object is used instead.
		 */
		UObject* m_Template = nullptr;

		/** Contains the mappings of instanced objects and components to their templates */
		//FObjectInstancingGraph* InstanceGraph = nullptr;

		/** Assign an external Package to the created object if non-null */
		//UPackage* ExternalPackage = nullptr;

		/** Callback for custom code to initialize properties before PostInitProperties runs */
		//TFunction<void()> PropertyInitCallback;

	private:
		//FObjectInitializer::FOverrides* SubobjectOverrides = nullptr;

	public:

		//COREUOBJECT_API FStaticConstructObjectParameters(const UClass* InClass);

		//friend FObjectInitializer;
	};

/**
 * Create a new instance of an object.  The returned object will be fully initialized.  If InFlags contains RF_NeedsLoad (indicating that the object still needs to load its object data from disk), components
 * are not instanced (this will instead occur in PostLoad()).  The different between StaticConstructObject and StaticAllocateObject is that StaticConstructObject will also call the class constructor on the object
 * and instance any components.
 *
 * @param	Params		The parameters to use when construction the object. @see FStaticConstructObjectParameters
 *
 * @return	A pointer to a fully initialized object of the specified class.
 */
KARMA_API UObject* StaticConstructObject_Internal(const FStaticConstructObjectParameters& Params);

/**
 * Create a new instance of an object or replace an existing object.  If both an Outer and Name are specified, and there is an object already in memory with the same Class, Outer, and Name, the
 * existing object will be destructed, and the new object will be created in its place.
 *
 * @param	Class		the class of the object to create
 * @param	InOuter		the object to create this object within (the Outer property for the new object will be set to the value specified here).
 * @param	Name		the name to give the new object. If no value (NAME_None) is specified, the object will be given a unique name in the form of ClassName_#.
 * @param	SetFlags	the ObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object.
 * @param InternalSetFlags	the InternalObjectFlags to assign to the new object. some flags can affect the behavior of constructing the object.
 * 
 * Rest shall be made available when reflection code is enabled
 * @param bCanReuseSubobjects	if set to true, SAO will not attempt to destroy a subobject if it already exists in memory.
 * @param bOutReusedSubobject	flag indicating if the object is a subobject that has already been created (in which case further initialization is not necessary).
 * @param ExternalPackage	External Package assigned to the allocated object, if any
 * @return	a pointer to a fully initialized object of the specified class.
 */
KARMA_API UObject* StaticAllocateObject(const UClass* Class, UObject* InOuter, const std::string& name, EObjectFlags SetFlags = EObjectFlags::RF_NoFlags, EInternalObjectFlags InternalSetFlags = EInternalObjectFlags::None);


/**
 * Convenience template for constructing a gameplay object
 *
 * @param	Outer		the outer for the new object.  If not specified, object will be created in the transient package. For AActors, Outer is the ULevel
 * @param	Class		the class of object to construct
 * @param	Name		the name for the new object.  If not specified, the object will be given a transient name via MakeUniqueObjectName
 * @param	Flags		the object flags to apply to the new object
 * @param	Template	the object to use for initializing the new object.  If not specified, the class's default object will be used. Not functional atm
 * @param	bCopyTransientsFromClassDefaults	if true, copy transient from the class defaults instead of the pass in archetype ptr (often these are the same)
 * @param	InInstanceGraph						contains the mappings of instanced objects and components to their templates
 * @param	ExternalPackage						Assign an external Package to the created object if non-null
 *
 * @return	a pointer of type T to a new object of the specified class
 */
template< class T >
FUNCTION_NON_NULL_RETURN_START
T* NewObject(UObject* Outer, const UClass* Class, std::string name = "No_Name", EObjectFlags Flags = RF_NoFlags, UObject* Template = nullptr, bool bCopyTransientsFromClassDefaults = false/*, FObjectInstancingGraph* InInstanceGraph = nullptr, UPackage* ExternalPackage = nullptr*/)
FUNCTION_NON_NULL_RETURN_END
{
	if (name == "")
	{
		KR_CORE_ASSERT(false, "NewObject with empty name can't be used to create default subobjects");
		//FObjectInitializer::AssertIfInConstructor(Outer, TEXT("NewObject with empty name can't be used to create default subobjects (inside of UObject derived class constructor) as it produces inconsistent object names. Use ObjectInitializer.CreateDefaultSubobject<> instead."));
	}

	FStaticConstructObjectParameters Params;
	Params.m_Class = Class;
	Params.m_Outer = Outer;
	Params.m_Name = name;
	Params.m_SetFlags = Flags;
	Params.m_Class = Class;
	//Params.m_Template = Template;
	Params.m_bCopyTransientsFromClassDefaults = bCopyTransientsFromClassDefaults;
	//Params.InstanceGraph = InInstanceGraph;
	//Params.ExternalPackage = ExternalPackage;

	return static_cast<T*>(StaticConstructObject_Internal(Params));
}

template< class T >
FUNCTION_NON_NULL_RETURN_START
T* NewObject(UObject* Outer, const std::string& Name, EObjectFlags Flags = RF_NoFlags, UObject* Template = nullptr, bool bCopyTransientsFromClassDefaults = false/*, FObjectInstancingGraph* InInstanceGraph = nullptr*/)
FUNCTION_NON_NULL_RETURN_END
{
	if (Name == "")
	{
		KR_CORE_ASSERT(false, "NewObject with empty name can't be used to create default subobjects");
		//FObjectInitializer::AssertIfInConstructor(Outer, TEXT("NewObject with empty name can't be used to create default subobjects (inside of UObject derived class constructor) as it produces inconsistent object names. Use ObjectInitializer.CreateDefaultSubobject<> instead."));
	}

	FStaticConstructObjectParameters Params;// (T::StaticClass());
	Params.m_Outer = Outer;
	Params.m_Name = Name;
	Params.m_SetFlags = Flags;
	//Params.Template = Template;
	Params.m_bCopyTransientsFromClassDefaults = bCopyTransientsFromClassDefaults;
	//Params.InstanceGraph = InInstanceGraph;

	return static_cast<T*>(StaticConstructObject_Internal(Params));
}

/**
 * A routine to find if the object is instantiated already. May need to modify in accordance with thread safety in future
 * UE name StaticFindObjectFastInternal
 * 
 * @param	ObjectClass			the class of object to construct 
 * @param	ObjectPackage		the outer where the object is supposed to be found
 * @param	ObjectName			the name for the object to be found
 * @param	bExactClass			class match check
 * @param	bAnyPackage			If there is no package (no InObjectPackage specified, and InName's package is "") and the caller specified any_package, then 
 *								accept it, regardless of its package.Or, if the object is a top-level package then accept it immediately
 * @param	ExcludeFlags		Don't return objects that have any of these exclusive flags set
 * @param	ExclusiveInternalFlags			Include (or not) pending kill objects
 * @param	ExternalPackage					Assign an external Package to the created object if non-null
 *
 * @return	a pointer of type UObject if found, else nulptr
 */
KARMA_API UObject* StaticFindObjectFastInternal(const UClass* ObjectClass, const UObject* ObjectPackage, const std::string& ObjectName, bool bExactClass = false, EObjectFlags ExcludeFlags = RF_NoFlags, EInternalObjectFlags ExclusiveInternalFlags = EInternalObjectFlags::None);

/**
 * Find an existing package by name or create it if it doesn't exist
 * @return The existing package or a newly created one
 *
 */
KARMA_API UPackage* CreatePackage(const std::string& PackageName);
}
