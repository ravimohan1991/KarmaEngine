<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>KarmaEngine: Karma::KarmaGui_ImplVulkanH_Window Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">KarmaEngine
   </div>
   <div id="projectbrief">Game Engine for practical learning and research purposes</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>Karma</b></li><li class="navelem"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___window.html">KarmaGui_ImplVulkanH_Window</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="struct_karma_1_1_karma_gui___impl_vulkan_h___window-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Karma::KarmaGui_ImplVulkanH_Window Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Helper structure to hold the data needed by one rendering context (Vulkan) of one OS window (Windows, Mac, or Linux).  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_karma_gui_vulkan_handler_8h_source.html">KarmaGuiVulkanHandler.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Karma::KarmaGui_ImplVulkanH_Window:</div>
<div class="dyncontent">
<div class="center"><img src="struct_karma_1_1_karma_gui___impl_vulkan_h___window__coll__graph.png" border="0" usemap="#a_karma_1_1_karma_gui___impl_vulkan_h___window_coll__map" alt="Collaboration graph"/></div>
<map name="a_karma_1_1_karma_gui___impl_vulkan_h___window_coll__map" id="a_karma_1_1_karma_gui___impl_vulkan_h___window_coll__map">
<area shape="rect" title="Helper structure to hold the data needed by one rendering context (Vulkan) of one OS window (Windows,..." alt="" coords="108,109,303,150"/>
<area shape="rect" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html" title="Helper structure to hold the data needed by one rendering ImageFrame (different from the FRAME_IN_FLI..." alt="" coords="5,5,201,46"/>
<area shape="poly" title=" " alt="" coords="135,55,188,107,184,110,131,59"/>
<area shape="rect" href="struct_karma_1_1_karma_gui___vulkan___frame___on___flight.html" title="Data structure for synchronous operations (relevant to rendering in this context)." alt="" coords="224,5,395,46"/>
<area shape="poly" title=" " alt="" coords="281,59,228,110,224,107,277,55"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a194b19fa100ff3c1f8399110f43d1346" id="r_a194b19fa100ff3c1f8399110f43d1346"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a194b19fa100ff3c1f8399110f43d1346">KarmaGui_ImplVulkanH_Window</a> ()</td></tr>
<tr class="memdesc:a194b19fa100ff3c1f8399110f43d1346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for zero clearence and relevant stuff.  <br /></td></tr>
<tr class="separator:a194b19fa100ff3c1f8399110f43d1346"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa4db1b8be13e11239d33886fadc68c22" id="r_aa4db1b8be13e11239d33886fadc68c22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4db1b8be13e11239d33886fadc68c22">Width</a></td></tr>
<tr class="memdesc:aa4db1b8be13e11239d33886fadc68c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Width dimension of the <a class="el" href="class_karma_1_1_window.html" title="The abstract base class of Karma&#39;s window (for platform specific purposes)">Window</a>.  <br /></td></tr>
<tr class="separator:aa4db1b8be13e11239d33886fadc68c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cefa4514741d3321ac04919eb93b66" id="r_a63cefa4514741d3321ac04919eb93b66"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63cefa4514741d3321ac04919eb93b66">Height</a></td></tr>
<tr class="memdesc:a63cefa4514741d3321ac04919eb93b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Height dimension of the <a class="el" href="class_karma_1_1_window.html" title="The abstract base class of Karma&#39;s window (for platform specific purposes)">Window</a>.  <br /></td></tr>
<tr class="separator:a63cefa4514741d3321ac04919eb93b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f1dfc23b34ff01932d56ce4ffb3677" id="r_a58f1dfc23b34ff01932d56ce4ffb3677"><td class="memItemLeft" align="right" valign="top">VkSwapchainKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58f1dfc23b34ff01932d56ce4ffb3677">Swapchain</a></td></tr>
<tr class="memdesc:a58f1dfc23b34ff01932d56ce4ffb3677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vulkan does not have the concept of a "default framebuffer", hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the swap chain and must be created explicitly in Vulkan. The swap chain is essentially a queue of images that are waiting to be presented to the screen. Our backend will acquire such an image to draw to it, and then return it to the queue. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#a2d367e332d968a2c5ba25c3759bff2b5" title="Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that...">VulkanContext::CreateSwapChain()</a>.  <br /></td></tr>
<tr class="separator:a58f1dfc23b34ff01932d56ce4ffb3677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61818fd8da13a8094c2674203da7b8ad" id="r_a61818fd8da13a8094c2674203da7b8ad"><td class="memItemLeft" align="right" valign="top">VkCommandPool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61818fd8da13a8094c2674203da7b8ad">CommandPool</a></td></tr>
<tr class="memdesc:a61818fd8da13a8094c2674203da7b8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command pools manage the memory that is used to store the buffers and command buffers are allocated from them. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#ae0919004c0e5350bf6af9cae89b7b0af" title="Command pools are opaque objects that command buffer memory is allocated from, and which allow the im...">VulkanContext::CreateCommandPool()</a>  <br /></td></tr>
<tr class="separator:a61818fd8da13a8094c2674203da7b8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa10731d8587c8deef70d4c518d3708bb" id="r_aa10731d8587c8deef70d4c518d3708bb"><td class="memItemLeft" align="right" valign="top">VkSurfaceKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa10731d8587c8deef70d4c518d3708bb">Surface</a></td></tr>
<tr class="memdesc:aa10731d8587c8deef70d4c518d3708bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">The surface is a cross-platform abstraction over windows to render to and is generally instantiated by providing a reference to the native window handle.  <br /></td></tr>
<tr class="separator:aa10731d8587c8deef70d4c518d3708bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8bae5646dd20a40fcd21661ec342d5" id="r_a5f8bae5646dd20a40fcd21661ec342d5"><td class="memItemLeft" align="right" valign="top">VkSurfaceFormatKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8bae5646dd20a40fcd21661ec342d5">SurfaceFormat</a></td></tr>
<tr class="memdesc:a5f8bae5646dd20a40fcd21661ec342d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure describing a supported swapchain format-color space pair. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#a2d367e332d968a2c5ba25c3759bff2b5" title="Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that...">VulkanContext::CreateSwapChain()</a>.  <br /></td></tr>
<tr class="separator:a5f8bae5646dd20a40fcd21661ec342d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b628dd62717a5417f969526b8d99db" id="r_a79b628dd62717a5417f969526b8d99db"><td class="memItemLeft" align="right" valign="top">VkPresentModeKHR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a79b628dd62717a5417f969526b8d99db">PresentMode</a></td></tr>
<tr class="memdesc:a79b628dd62717a5417f969526b8d99db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Presentation mode supported for a surface. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#a2d367e332d968a2c5ba25c3759bff2b5" title="Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that...">VulkanContext::CreateSwapChain()</a>.  <br /></td></tr>
<tr class="separator:a79b628dd62717a5417f969526b8d99db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d9377756e00c570039afb468533d9d3" id="r_a3d9377756e00c570039afb468533d9d3"><td class="memItemLeft" align="right" valign="top">VkRenderPass&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d9377756e00c570039afb468533d9d3">RenderPass</a></td></tr>
<tr class="memdesc:a3d9377756e00c570039afb468533d9d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A render pass object represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses.  <br /></td></tr>
<tr class="separator:a3d9377756e00c570039afb468533d9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05bf8e8465adb8549675dc38068e7cb" id="r_ac05bf8e8465adb8549675dc38068e7cb"><td class="memItemLeft" align="right" valign="top">VkPipeline&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac05bf8e8465adb8549675dc38068e7cb">Pipeline</a></td></tr>
<tr class="memdesc:ac05bf8e8465adb8549675dc38068e7cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw. Once a pipeline is built, it can be bound inside a command buffer, and then when you draw anything it will use the bound pipeline.  <br /></td></tr>
<tr class="separator:ac05bf8e8465adb8549675dc38068e7cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dc4032e7d0af1490711e4dfa1b0095" id="r_aa7dc4032e7d0af1490711e4dfa1b0095"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa7dc4032e7d0af1490711e4dfa1b0095">ClearEnable</a></td></tr>
<tr class="memdesc:aa7dc4032e7d0af1490711e4dfa1b0095"><td class="mdescLeft">&#160;</td><td class="mdescRight">No clue about the usage.  <br /></td></tr>
<tr class="separator:aa7dc4032e7d0af1490711e4dfa1b0095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acafd0e137d0e40569b62c1bb7019eb49" id="r_acafd0e137d0e40569b62c1bb7019eb49"><td class="memItemLeft" align="right" valign="top">VkClearValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acafd0e137d0e40569b62c1bb7019eb49">ClearValue</a></td></tr>
<tr class="memdesc:acafd0e137d0e40569b62c1bb7019eb49"><td class="mdescLeft">&#160;</td><td class="mdescRight">VkClearValue structures containing clear values for each attachment, if the attachment uses a loadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a stencilLoadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored.  <br /></td></tr>
<tr class="separator:acafd0e137d0e40569b62c1bb7019eb49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb0df6cabf489dbb139796e6aa53ba75" id="r_adb0df6cabf489dbb139796e6aa53ba75"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb0df6cabf489dbb139796e6aa53ba75">ImageFrameIndex</a></td></tr>
<tr class="memdesc:adb0df6cabf489dbb139796e6aa53ba75"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number count of the image, returned by vkGetSwapchainImagesKHR, usually range derived from min_image_count, to be addressed for frame (each loop iteration) rendering logic.  <br /></td></tr>
<tr class="separator:adb0df6cabf489dbb139796e6aa53ba75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada96e70fe3975b6b5f12407463f21c0b" id="r_ada96e70fe3975b6b5f12407463f21c0b"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada96e70fe3975b6b5f12407463f21c0b">TotalImageCount</a></td></tr>
<tr class="memdesc:ada96e70fe3975b6b5f12407463f21c0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total Number of the images supported by swapchain.  <br /></td></tr>
<tr class="separator:ada96e70fe3975b6b5f12407463f21c0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2434955c7533a2fea20d7acd813634e9" id="r_a2434955c7533a2fea20d7acd813634e9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2434955c7533a2fea20d7acd813634e9">SemaphoreIndex</a></td></tr>
<tr class="memdesc:a2434955c7533a2fea20d7acd813634e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current set of swapchain wait semaphores and command buffers we're using (0 &lt;= SemaphoreIndex &lt; MAX_FRAMES_IN_FLIGHT)  <br /></td></tr>
<tr class="separator:a2434955c7533a2fea20d7acd813634e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4040e45840d9a92ebcfa7b1252bab0b9" id="r_a4040e45840d9a92ebcfa7b1252bab0b9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4040e45840d9a92ebcfa7b1252bab0b9">MAX_FRAMES_IN_FLIGHT</a></td></tr>
<tr class="memdesc:a4040e45840d9a92ebcfa7b1252bab0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is representative of (linearly proportional to or indicative of) number of commandbuffer recordings on CPU that may happen whilst the rendering is being done on GPU. That should determine the semaphore, fence, and commandbuffer size.  <br /></td></tr>
<tr class="separator:a4040e45840d9a92ebcfa7b1252bab0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827c0cf1d334104bdb429ca3030afd76" id="r_a827c0cf1d334104bdb429ca3030afd76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html">KarmaGui_ImplVulkanH_ImageFrame</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a827c0cf1d334104bdb429ca3030afd76">ImageFrames</a></td></tr>
<tr class="memdesc:a827c0cf1d334104bdb429ca3030afd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just a container for buffers and all those sizes depending on VulkanHolder::GetVulkanContext()-&gt;GetSwapChainImages().size();.  <br /></td></tr>
<tr class="separator:a827c0cf1d334104bdb429ca3030afd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e83a6e76e046beb3704892784f58fc3" id="r_a4e83a6e76e046beb3704892784f58fc3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_karma_1_1_karma_gui___vulkan___frame___on___flight.html">KarmaGui_Vulkan_Frame_On_Flight</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e83a6e76e046beb3704892784f58fc3">FramesOnFlight</a></td></tr>
<tr class="memdesc:a4e83a6e76e046beb3704892784f58fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data for synchronous operations of in-flight rendering frames.  <br /></td></tr>
<tr class="separator:a4e83a6e76e046beb3704892784f58fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b444633145dd5dd0ed01a67c9f75603" id="r_a5b444633145dd5dd0ed01a67c9f75603"><td class="memItemLeft" align="right" valign="top">VkRect2D&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b444633145dd5dd0ed01a67c9f75603">RenderArea</a></td></tr>
<tr class="memdesc:a5b444633145dd5dd0ed01a67c9f75603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most likely the glfw window size, set from VulkanHolder::GetVulkanContext()-&gt;GetSwapChainExtent(). Used for setting renderPassInfo.renderArea.extent in KarmaGuiRenderer::FrameRender.  <br /></td></tr>
<tr class="separator:a5b444633145dd5dd0ed01a67c9f75603"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Helper structure to hold the data needed by one rendering context (Vulkan) of one OS window (Windows, Mac, or Linux). </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a194b19fa100ff3c1f8399110f43d1346" name="a194b19fa100ff3c1f8399110f43d1346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194b19fa100ff3c1f8399110f43d1346">&#9670;&#160;</a></span>KarmaGui_ImplVulkanH_Window()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Karma::KarmaGui_ImplVulkanH_Window::KarmaGui_ImplVulkanH_Window </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor for zero clearence and relevant stuff. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa7dc4032e7d0af1490711e4dfa1b0095" name="aa7dc4032e7d0af1490711e4dfa1b0095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc4032e7d0af1490711e4dfa1b0095">&#9670;&#160;</a></span>ClearEnable</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Karma::KarmaGui_ImplVulkanH_Window::ClearEnable</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No clue about the usage. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="acafd0e137d0e40569b62c1bb7019eb49" name="acafd0e137d0e40569b62c1bb7019eb49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acafd0e137d0e40569b62c1bb7019eb49">&#9670;&#160;</a></span>ClearValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkClearValue Karma::KarmaGui_ImplVulkanH_Window::ClearValue</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>VkClearValue structures containing clear values for each attachment, if the attachment uses a loadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR or if the attachment has a depth/stencil format and uses a stencilLoadOp value of VK_ATTACHMENT_LOAD_OP_CLEAR. The array is indexed by attachment number. Only elements corresponding to cleared attachments are used. Other elements of pClearValues are ignored. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a61818fd8da13a8094c2674203da7b8ad" name="a61818fd8da13a8094c2674203da7b8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61818fd8da13a8094c2674203da7b8ad">&#9670;&#160;</a></span>CommandPool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkCommandPool Karma::KarmaGui_ImplVulkanH_Window::CommandPool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Command pools manage the memory that is used to store the buffers and command buffers are allocated from them. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#ae0919004c0e5350bf6af9cae89b7b0af" title="Command pools are opaque objects that command buffer memory is allocated from, and which allow the im...">VulkanContext::CreateCommandPool()</a> </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a4e83a6e76e046beb3704892784f58fc3" name="a4e83a6e76e046beb3704892784f58fc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e83a6e76e046beb3704892784f58fc3">&#9670;&#160;</a></span>FramesOnFlight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_karma_1_1_karma_gui___vulkan___frame___on___flight.html">KarmaGui_Vulkan_Frame_On_Flight</a>* Karma::KarmaGui_ImplVulkanH_Window::FramesOnFlight</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Data for synchronous operations of in-flight rendering frames. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a63cefa4514741d3321ac04919eb93b66" name="a63cefa4514741d3321ac04919eb93b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cefa4514741d3321ac04919eb93b66">&#9670;&#160;</a></span>Height</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Karma::KarmaGui_ImplVulkanH_Window::Height</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Height dimension of the <a class="el" href="class_karma_1_1_window.html" title="The abstract base class of Karma&#39;s window (for platform specific purposes)">Window</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Used in <a class="el" href="class_karma_1_1_karma_gui_vulkan_handler.html#a72b73653d18fdde91d1225e63abf9313" title="A set of instructions for rendering a viewport of KarmaGui window (called each loop for realtime Vulk...">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_RenderWindow</a> which is not used in current state of the Engine.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="adb0df6cabf489dbb139796e6aa53ba75" name="adb0df6cabf489dbb139796e6aa53ba75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0df6cabf489dbb139796e6aa53ba75">&#9670;&#160;</a></span>ImageFrameIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Karma::KarmaGui_ImplVulkanH_Window::ImageFrameIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number count of the image, returned by vkGetSwapchainImagesKHR, usually range derived from min_image_count, to be addressed for frame (each loop iteration) rendering logic. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a827c0cf1d334104bdb429ca3030afd76" name="a827c0cf1d334104bdb429ca3030afd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827c0cf1d334104bdb429ca3030afd76">&#9670;&#160;</a></span>ImageFrames</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_karma_1_1_karma_gui___impl_vulkan_h___image_frame.html">KarmaGui_ImplVulkanH_ImageFrame</a>* Karma::KarmaGui_ImplVulkanH_Window::ImageFrames</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Just a container for buffers and all those sizes depending on VulkanHolder::GetVulkanContext()-&gt;GetSwapChainImages().size();. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a4040e45840d9a92ebcfa7b1252bab0b9" name="a4040e45840d9a92ebcfa7b1252bab0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4040e45840d9a92ebcfa7b1252bab0b9">&#9670;&#160;</a></span>MAX_FRAMES_IN_FLIGHT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Karma::KarmaGui_ImplVulkanH_Window::MAX_FRAMES_IN_FLIGHT</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is representative of (linearly proportional to or indicative of) number of commandbuffer recordings on CPU that may happen whilst the rendering is being done on GPU. That should determine the semaphore, fence, and commandbuffer size. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ac05bf8e8465adb8549675dc38068e7cb" name="ac05bf8e8465adb8549675dc38068e7cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05bf8e8465adb8549675dc38068e7cb">&#9670;&#160;</a></span>Pipeline</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPipeline Karma::KarmaGui_ImplVulkanH_Window::Pipeline</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A huge object in Vulkan that encompasses the configuration of the entire GPU for the draw. Once a pipeline is built, it can be bound inside a command buffer, and then when you draw anything it will use the bound pipeline. </p>
<dl class="section note"><dt>Note</dt><dd>The window pipeline may use a different VkRenderPass than the one passed in ImGui_ImplVulkan_InitInfo. Need to investigate why. </dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a79b628dd62717a5417f969526b8d99db" name="a79b628dd62717a5417f969526b8d99db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b628dd62717a5417f969526b8d99db">&#9670;&#160;</a></span>PresentMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkPresentModeKHR Karma::KarmaGui_ImplVulkanH_Window::PresentMode</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Presentation mode supported for a surface. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#a2d367e332d968a2c5ba25c3759bff2b5" title="Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that...">VulkanContext::CreateSwapChain()</a>. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a5b444633145dd5dd0ed01a67c9f75603" name="a5b444633145dd5dd0ed01a67c9f75603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b444633145dd5dd0ed01a67c9f75603">&#9670;&#160;</a></span>RenderArea</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkRect2D Karma::KarmaGui_ImplVulkanH_Window::RenderArea</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Most likely the glfw window size, set from VulkanHolder::GetVulkanContext()-&gt;GetSwapChainExtent(). Used for setting renderPassInfo.renderArea.extent in KarmaGuiRenderer::FrameRender. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000084">Todo</a></b></dt><dd>Ponder, how to implement the context switch from Editor rendering to Game rendering.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a3d9377756e00c570039afb468533d9d3" name="a3d9377756e00c570039afb468533d9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d9377756e00c570039afb468533d9d3">&#9670;&#160;</a></span>RenderPass</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkRenderPass Karma::KarmaGui_ImplVulkanH_Window::RenderPass</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A render pass object represents a collection of attachments, subpasses, and dependencies between the subpasses, and describes how the attachments are used over the course of the subpasses. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a2434955c7533a2fea20d7acd813634e9" name="a2434955c7533a2fea20d7acd813634e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2434955c7533a2fea20d7acd813634e9">&#9670;&#160;</a></span>SemaphoreIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Karma::KarmaGui_ImplVulkanH_Window::SemaphoreIndex</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current set of swapchain wait semaphores and command buffers we're using (0 &lt;= SemaphoreIndex &lt; MAX_FRAMES_IN_FLIGHT) </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aa10731d8587c8deef70d4c518d3708bb" name="aa10731d8587c8deef70d4c518d3708bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa10731d8587c8deef70d4c518d3708bb">&#9670;&#160;</a></span>Surface</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSurfaceKHR Karma::KarmaGui_ImplVulkanH_Window::Surface</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The surface is a cross-platform abstraction over windows to render to and is generally instantiated by providing a reference to the native window handle. </p>
<dl class="section note"><dt>Note</dt><dd>The vulkan backend, in current stance, is not using the surface created in VulkanContext::CreateSurface() since all the surface relevant operations have already been done in <a class="el" href="class_karma_1_1_vulkan_context.html" title="Vulkan API has the following concepts.">VulkanContext</a>.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a5f8bae5646dd20a40fcd21661ec342d5" name="a5f8bae5646dd20a40fcd21661ec342d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8bae5646dd20a40fcd21661ec342d5">&#9670;&#160;</a></span>SurfaceFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSurfaceFormatKHR Karma::KarmaGui_ImplVulkanH_Window::SurfaceFormat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Structure describing a supported swapchain format-color space pair. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#a2d367e332d968a2c5ba25c3759bff2b5" title="Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that...">VulkanContext::CreateSwapChain()</a>. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="a58f1dfc23b34ff01932d56ce4ffb3677" name="a58f1dfc23b34ff01932d56ce4ffb3677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f1dfc23b34ff01932d56ce4ffb3677">&#9670;&#160;</a></span>Swapchain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VkSwapchainKHR Karma::KarmaGui_ImplVulkanH_Window::Swapchain</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vulkan does not have the concept of a "default framebuffer", hence it requires an infrastructure that will own the buffers we will render to before we visualize them on the screen. This infrastructure is known as the swap chain and must be created explicitly in Vulkan. The swap chain is essentially a queue of images that are waiting to be presented to the screen. Our backend will acquire such an image to draw to it, and then return it to the queue. Taken from <a class="el" href="class_karma_1_1_vulkan_context.html#a2d367e332d968a2c5ba25c3759bff2b5" title="Vulkan does not have the concept of a &quot;default framebuffer&quot;, hence it requires an infrastructure that...">VulkanContext::CreateSwapChain()</a>. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="ada96e70fe3975b6b5f12407463f21c0b" name="ada96e70fe3975b6b5f12407463f21c0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada96e70fe3975b6b5f12407463f21c0b">&#9670;&#160;</a></span>TotalImageCount</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t Karma::KarmaGui_ImplVulkanH_Window::TotalImageCount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total Number of the images supported by swapchain. </p>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<a id="aa4db1b8be13e11239d33886fadc68c22" name="aa4db1b8be13e11239d33886fadc68c22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4db1b8be13e11239d33886fadc68c22">&#9670;&#160;</a></span>Width</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Karma::KarmaGui_ImplVulkanH_Window::Width</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Width dimension of the <a class="el" href="class_karma_1_1_window.html" title="The abstract base class of Karma&#39;s window (for platform specific purposes)">Window</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Used in <a class="el" href="class_karma_1_1_karma_gui_vulkan_handler.html#a72b73653d18fdde91d1225e63abf9313" title="A set of instructions for rendering a viewport of KarmaGui window (called each loop for realtime Vulk...">KarmaGuiVulkanHandler::KarmaGui_ImplVulkan_RenderWindow</a> which is not used in current state of the Engine.</dd></dl>
<dl class="section since"><dt>Since</dt><dd>Karma 1.0.0 </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>Karma/src/Platform/Vulkan/<a class="el" href="_karma_gui_vulkan_handler_8h_source.html">KarmaGuiVulkanHandler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.13.2
</small></address>
</div><!-- doc-content -->
</body>
</html>
